{"id":null,"title":"caal-exercises-feb-22","ccs":"* Exercise 3\n\nA = (C0 | C1 | C2)\\{c, d};\nC0 = C[c/b];\nC1 = C[c/a, d/b];\nC2 = C[d/a];\nC = a.'b.C;\n\n* Aqui lo que esta pasando es que se esta relabeando el proceso C en C0, C1, C2 de la forma:\n* C0 = a.'c.C0\n* C1 = c.d'.C1\n* C2 = d.'b.C2\n\n* Por otro lado A recoge esos tres procesos y los ejecuta en paralelo, esto es, que mediante la regla de derivacion COM1, COM2 y COM3 podemos observar secuencias como a.tau.tau.(...) o a.tau.a(...).\n* Aqui realmente lo que esta haciendo es sincronizar las acciones con su label dual. Entonces por ejemplo:\n\n* como ocurre C0 | C1, se tiene que podemos hacer para C0 a.'c y en este momento sincronizar con C1 porque es c.'d.C1 consiguiento:      a.tau.'d (...) ; a continuacion podemos conseguir a.tau.tau porque C0 | C1 | C2 y C2 es d.'b.C2, o incluso podemos conseguir a.tau.a porque podemos seguir actuando sobre C0. Y asi sucesivamente.\n\n\nB = B10 | B10 | B10;\nB10 = a.B11;\nB11 = 'b.B10;\n\n* Ejemplo de interruptores encendiendose consecutivamente\n* Always inmediatly an action a there is exist an action 'b\n\n* ----------------------------------------\n\n* Exercise 4\nQ = a.Q1;\nQ1 = 'b.Q + a.Q2;\nQ2 = 'b.Q1 + a.Q3;\nQ3 = 'b.Q2;\n","properties":[{"className":"HML","status":3,"options":{"process":"B","definitions":"","topFormula":"[a]<'b>tt;","comment":""}},{"className":"Bisimulation","status":0,"options":{"type":"strong","time":null,"firstProcess":"Q","secondProcess":"B","comment":""}}],"inputMode":"CCS"}