1:1-1:1::$trModule :: "GHC.Types.Module"
23:1-23:5::main :: "(GHC.Types.IO ())"
23:17-23:24::lq_anf$##7205759403792801055 :: "[GHC.Types.Char]"
32:1-32:4::die :: "forall a . {v : [GHC.Types.Char] | false} -> a"
32:5-32:8::msg :: "{VV : [GHC.Types.Char] | false}"
32:17-32:20::msg :: "{v : [GHC.Types.Char] | false}"
49:1-49:7::divide :: "GHC.Types.Int -> {VV : GHC.Types.Int | 0 /= VV} -> GHC.Types.Int"
49:14-49:34::die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
49:18-49:34::lq_anf$##7205759403792801080 :: "[GHC.Types.Char]"
50:14-50:15::ds_d1TB :: "GHC.Types.Int"
50:22-50:23::ds_d1TC :: "{v : GHC.Types.Int | 0 /= v}"
61:1-61:5::avg2 :: "GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int"
61:6-61:7::x :: "GHC.Types.Int"
61:8-61:9::y :: "GHC.Types.Int"
61:21-61:28::lq_anf$##7205759403792801081 :: "{v : GHC.Types.Int | v == x + y}"
61:22-61:23::x :: "{v : GHC.Types.Int | v == x}"
61:26-61:27::y :: "{v : GHC.Types.Int | v == y}"
61:33-61:34::lq_anf$##7205759403792801083 :: "GHC.Types.Int"
63:1-63:5::avg3 :: "GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int"
63:6-63:7::x :: "GHC.Types.Int"
63:8-63:9::y :: "GHC.Types.Int"
63:10-63:11::z :: "GHC.Types.Int"
63:21-63:32::lq_anf$##7205759403792801085 :: "GHC.Types.Int"
63:22-63:23::x :: "{v : GHC.Types.Int | v == x}"
63:26-63:27::y :: "{v : GHC.Types.Int | v == y}"
63:30-63:31::z :: "{v : GHC.Types.Int | v == z}"
63:33-63:34::lq_anf$##7205759403792801087 :: "GHC.Types.Int"
72:1-72:5::size :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | (notEmpty x1 => VV > 0)\n                                && VV >= 0}"
72:16-72:17::lq_anf$##7205759403792801112 :: "{v : GHC.Prim.Int# | v == 0}"
73:16-73:17::lq_anf$##7205759403792801114 :: "GHC.Types.Int"
73:20-73:27::lq_anf$##7205759403792801115 :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v >= 0}"
73:25-73:27::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
79:1-79:8::avgMany :: "[GHC.Types.Int] -> GHC.Types.Int"
79:9-79:11::xs :: "[GHC.Types.Int]"
79:14-79:32::divide :: "GHC.Types.Int -> {v : GHC.Types.Int | 0 /= v} -> GHC.Types.Int"
79:21-79:26::total :: "{v : GHC.Types.Int | v == total}"
79:27-79:32::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v == elems\n                     && v >= 0}"
81:5-81:10::total :: "GHC.Types.Int"
81:14-81:21::_ :: "GHC.Types.Int"
81:19-81:21::xs :: "{v : [GHC.Types.Int] | v == xs\n                       && len v >= 0}"
82:5-82:10::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v >= 0}"
82:14-82:21::size :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | (notEmpty x1 => VV > 0)\n                                && VV >= 0}"
82:19-82:21::xs :: "{v : [GHC.Types.Int] | v == xs\n                       && len v >= 0}"
115:1-115:9::notEmpty :: "forall a . x1:[a] -> {VV : GHC.Types.Bool | VV <=> notEmpty x1}"
115:18-115:23::False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
116:18-116:22::True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
157:1-157:8::average :: "{VV : [GHC.Types.Int] | notEmpty VV} -> GHC.Types.Int"
157:9-157:11::xs :: "{VV : [GHC.Types.Int] | notEmpty VV}"
157:14-157:32::divide :: "GHC.Types.Int -> {v : GHC.Types.Int | 0 /= v} -> GHC.Types.Int"
157:21-157:26::total :: "{v : GHC.Types.Int | v == total}"
157:27-157:32::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v == elems\n                     && v >= 0}"
159:5-159:10::total :: "GHC.Types.Int"
159:14-159:20::_ :: "GHC.Types.Int"
159:18-159:20::xs :: "{v : [GHC.Types.Int] | notEmpty v\n                       && v == xs\n                       && len v >= 0}"
160:5-160:10::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v >= 0}"
160:14-160:21::size :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | (notEmpty x1 => VV > 0)\n                                && VV >= 0}"
160:19-160:21::xs :: "{v : [GHC.Types.Int] | notEmpty v\n                       && v == xs\n                       && len v >= 0}"
170:1-170:9::average' :: "[GHC.Types.Int] -> (GHC.Maybe.Maybe GHC.Types.Int)"
170:10-170:12::xs :: "[GHC.Types.Int]"
171:17-171:21::_ :: "{VV : forall a .\n      x1:a -> {v : (GHC.Maybe.Maybe a) | isJust v\n                                         && fromJust v == x1} | VV == Just}"
171:24-171:45::lq_anf$##7205759403792801152 :: "GHC.Types.Int"
171:31-171:39::lq_anf$##7205759403792801151 :: "GHC.Types.Int"
171:36-171:38::xs :: "{v : [GHC.Types.Int] | v == xs\n                       && len v >= 0}"
171:40-171:45::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v == elems\n                     && v >= 0}"
172:17-172:24::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}"
174:5-174:10::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v >= 0}"
174:17-174:24::size :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | (notEmpty x1 => VV > 0)\n                                && VV >= 0}"
174:22-174:24::xs :: "{v : [GHC.Types.Int] | v == xs\n                       && len v >= 0}"
175:17-175:28::lq_anf$##7205759403792801148 :: "{v : GHC.Types.Bool | v <=> notEmpty xs}"
175:26-175:28::xs :: "{v : [GHC.Types.Int] | v == xs\n                       && len v >= 0}"
188:1-188:6::size1 :: "forall a .\n{VV : [a] | notEmpty VV} -> {VV : GHC.Types.Int | 0 < VV}"
188:17-188:18::lq_anf$##7205759403792801123 :: "{v : GHC.Prim.Int# | v == 1}"
189:17-189:18::lq_anf$##7205759403792801121 :: "GHC.Types.Int"
189:21-189:29::lq_anf$##7205759403792801122 :: "{v : GHC.Types.Int | 0 < v}"
189:27-189:29::ds_d1SK :: "{v : [a] | len v >= 0}"
192:1-192:6::size2 :: "forall a . x1:[a] -> {v : GHC.Types.Int | notEmpty x1 => v > 0}"
192:19-192:20::lq_anf$##7205759403792801127 :: "{v : GHC.Prim.Int# | v == 0}"
193:19-193:27::size1 :: "forall a .\n{VV : [a] | notEmpty VV} -> {VV : GHC.Types.Int | 0 < VV}"
193:25-193:27::ds_d1SP :: "{v : [a] | len v >= 0}"
211:1-211:5::head :: "forall a . {VV : [a] | notEmpty VV} -> a"
211:15-211:16::x :: "{VV : a | VV == x}"
212:15-212:56::die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
212:19-212:56::lq_anf$##7205759403792801090 :: "[GHC.Types.Char]"
215:1-215:5::tail :: "forall a . {VV : [a] | notEmpty VV} -> [a]"
215:15-215:17::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
216:15-216:54::die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
216:19-216:54::lq_anf$##7205759403792801093 :: "[GHC.Types.Char]"
237:1-237:9::safeHead :: "forall a . [a] -> (GHC.Maybe.Maybe a)"
237:10-237:12::xs :: "[a]"
238:5-238:12::lq_anf$##7205759403792801129 :: "{v : GHC.Types.Bool | v <=> not (notEmpty xs)}"
238:10-238:12::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
238:17-238:24::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}"
239:17-239:21::_ :: "{VV : forall a .\n      x1:a -> {v : (GHC.Maybe.Maybe a) | isJust v\n                                         && fromJust v == x1} | VV == Just}"
239:24-239:31::lq_anf$##7205759403792801132 :: "a"
239:29-239:31::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
242:1-242:5::null :: "forall a . x1:[a] -> {b : GHC.Types.Bool | b <=> not (notEmpty x1)}"
242:18-242:22::True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
243:18-243:23::False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
252:1-252:8::groupEq :: "forall a . (Eq<[]> a) => [a] -> [{VV : [a] | notEmpty VV}]"
252:18-252:20::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | not (notEmpty v)\n                                                  && len v == 0} | VV == []}"
253:18-253:24::lq_anf$##7205759403792801135 :: "{v : [a] | notEmpty v\n           && head v == x\n           && len v == 1 + len ys\n           && tail v == ys}"
253:19-253:20::x :: "{VV : a | VV == x}"
253:21-253:23::ys :: "{v : [a] | v == ys\n           && len v >= 0\n           && len v <= len xs}"
253:27-253:37::lq_anf$##7205759403792801136 :: "[{v : [a] | notEmpty v}]"
253:35-253:37::zs :: "{v : [a] | v == zs\n           && len v >= 0\n           && len v <= len xs}"
255:6-255:8::ys :: "{VV : [a] | len VV >= 0\n            && len VV <= len xs}"
255:10-255:12::zs :: "{VV : [a] | len VV >= 0\n            && len VV <= len xs}"
255:18-255:32::lq_anf$##7205759403792801134 :: "x1:a -> {v : GHC.Types.Bool | v <=> x == x1}"
255:23-255:29::_ :: "GHC.Types.Bool"
255:24-255:25::x :: "{VV : a | VV == x}"
255:30-255:32::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
270:1-270:17::eliminateStutter :: "forall a . (Eq<[]> a) => [a] -> [a]"
270:18-270:20::xs :: "[a]"
270:23-270:31::lq_anf$##7205759403792801169 :: "x1:[[a]] -> {v : [a] | notEmpty x1 <=> notEmpty v}"
270:27-270:31::_ :: "{VV : forall a . {v : [a] | notEmpty v} -> a | VV == head}"
270:34-270:44::lq_anf$##7205759403792801170 :: "[{v : [a] | notEmpty v}]"
270:42-270:44::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
284:1-284:7::foldl1 :: "forall a . (a -> a -> a) -> {VV : [a] | notEmpty VV} -> a"
284:8-284:9::f :: "a -> a -> a"
284:22-284:34::foldl :: "forall a b . (a -> b -> a) -> a -> [b] -> a"
284:28-284:29::f :: "a -> a -> a"
284:30-284:31::x :: "{VV : a | VV == x}"
284:32-284:34::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
285:22-285:34::die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
285:26-285:34::lq_anf$##7205759403792801141 :: "[GHC.Types.Char]"
288:1-288:6::foldl :: "forall a b . (a -> b -> a) -> a -> [b] -> a"
288:9-288:12::acc :: "a"
288:22-288:25::acc :: "{VV : a | VV == acc}"
289:22-289:42::foldl :: "forall a b . (a -> b -> a) -> a -> [b] -> a"
289:28-289:29::ds_d1Rt :: "a -> b -> a"
289:30-289:39::lq_anf$##7205759403792801138 :: "a"
289:33-289:36::acc :: "{VV : a | VV == acc}"
289:37-289:38::x :: "{VV : a | VV == x}"
289:40-289:42::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
299:1-299:4::sum :: "forall a . (Num<[]> a) => {VV : [a] | notEmpty VV} -> a"
299:11-299:41::die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
299:15-299:41::lq_anf$##7205759403792801145 :: "[GHC.Types.Char]"
300:11-300:24::foldl1 :: "{VV : forall a .\n      (a -> a -> a) -> {v : [a] | notEmpty v} -> a | VV == foldl1}"
300:18-300:21::lq_anf$##7205759403792801143 :: "x1:a -> x2:a -> {VV : a | VV == x1 + x2}"
300:22-300:24::ds_d1UM :: "{v : [a] | notEmpty v\n           && len v >= 0}"
306:1-306:6::sumOk :: "GHC.Integer.Type.Integer"
306:14-306:25::lq_anf$##7205759403792801163 :: "{v : [GHC.Integer.Type.Integer] | notEmpty v}"
306:15-306:16::lq_anf$##7205759403792801153 :: "{v : GHC.Integer.Type.Integer | v == 1}"
306:17-306:18::lq_anf$##7205759403792801154 :: "{v : GHC.Integer.Type.Integer | v == 2}"
306:19-306:20::lq_anf$##7205759403792801155 :: "{v : GHC.Integer.Type.Integer | v == 3}"
306:21-306:22::lq_anf$##7205759403792801156 :: "{v : GHC.Integer.Type.Integer | v == 4}"
306:23-306:24::lq_anf$##7205759403792801157 :: "{v : GHC.Integer.Type.Integer | v == 5}"
308:1-308:7::sumBad :: "GHC.Integer.Type.Integer"
308:14-308:16::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | not (notEmpty v)\n                                                  && len v == 0} | VV == []}"
319:1-319:10::wtAverage :: "{VV : [({VV : GHC.Types.Int | 0 < VV}, {VV : GHC.Types.Int | 0 < VV})] | notEmpty VV} -> GHC.Types.Int"
319:11-319:14::wxs :: "{VV : [({VV : GHC.Types.Int | 0 < VV}, {VV : GHC.Types.Int | 0 < VV})] | notEmpty VV}"
319:17-319:42::divide :: "GHC.Types.Int -> {v : GHC.Types.Int | 0 /= v} -> GHC.Types.Int"
319:24-319:32::totElems :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && v == totElems\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
319:33-319:42::totWeight :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && v == totWeight\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
321:5-321:10::elems :: "{v : [GHC.Types.Int] | notEmpty wxs <=> notEmpty v}"
321:17-321:43::lq_anf$##7205759403792801175 :: "(GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Int"
321:21-321:39::lq_anf$##7205759403792801174 :: "(GHC.Types.Int, GHC.Types.Int)"
321:33-321:34::w :: "{v : GHC.Types.Int | v == w}"
321:37-321:38::x :: "{v : GHC.Types.Int | v == x}"
321:40-321:43::wxs :: "{v : [({v : GHC.Types.Int | 0 < v}, {v : GHC.Types.Int | 0 < v})] | notEmpty v\n                                                                    && v == wxs\n                                                                    && len v >= 0}"
322:5-322:12::weights :: "{v : [GHC.Types.Int] | notEmpty wxs <=> notEmpty v}"
322:17-322:43::lq_anf$##7205759403792801173 :: "({VV : GHC.Types.Int | (notEmpty wxs => VV > 0)\n                       && 0 /= VV\n                       && VV /= 0\n                       && VV > 0\n                       && VV >= 0\n                       && 0 < VV}, GHC.Types.Int) -> GHC.Types.Int"
322:21-322:39::lq_anf$##7205759403792801172 :: "({v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                      && 0 /= v\n                      && v /= 0\n                      && v > 0\n                      && v >= 0\n                      && 0 < v}, GHC.Types.Int)"
322:33-322:34::w :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && v == w\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
322:40-322:43::wxs :: "{v : [({v : GHC.Types.Int | 0 < v}, {v : GHC.Types.Int | 0 < v})] | notEmpty v\n                                                                    && v == wxs\n                                                                    && len v >= 0}"
323:5-323:13::totElems :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
323:17-323:26::_ :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
323:21-323:26::elems :: "{v : [GHC.Types.Int] | (notEmpty wxs <=> notEmpty v)\n                       && v == elems\n                       && len v >= 0}"
324:5-324:14::totWeight :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
324:17-324:28::_ :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
324:21-324:28::weights :: "{v : [GHC.Types.Int] | (notEmpty wxs <=> notEmpty v)\n                       && v == weights\n                       && len v >= 0}"
325:5-325:8::sum :: "{v : [{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                           && 0 /= v\n                           && v /= 0\n                           && v > 0\n                           && v >= 0\n                           && 0 < v}] | notEmpty v} -> {v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                                                                            && 0 /= v\n                                                                            && v /= 0\n                                                                            && v > 0\n                                                                            && v >= 0\n                                                                            && 0 < v}"
325:17-325:27::_ :: "{v : [{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                           && 0 /= v\n                           && v /= 0\n                           && v > 0\n                           && v >= 0\n                           && 0 < v}] | notEmpty v} -> {v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                                                                            && 0 /= v\n                                                                            && v /= 0\n                                                                            && v > 0\n                                                                            && v >= 0\n                                                                            && 0 < v}"
325:24-325:27::lq_anf$##7205759403792801171 :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 + x2}"
328:1-328:4::map :: "forall a b .\n(a -> b) -> x3:[a] -> {ys : [b] | notEmpty x3 <=> notEmpty ys}"
328:18-328:20::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | not (notEmpty v)\n                                                  && len v == 0} | VV == []}"
329:18-329:21::lq_anf$##7205759403792801166 :: "a"
329:20-329:21::x :: "{VV : a | VV == x}"
329:24-329:32::lq_anf$##7205759403792801167 :: "{v : [a] | notEmpty xs <=> notEmpty v}"
329:28-329:29::ds_d1Rh :: "a -> b"
329:30-329:32::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
348:1-348:7::risers :: "forall a .\n(Ord<[]> a) =>\nx2:[a] -> {v : [[a]] | notEmpty x2 => notEmpty v}"
348:20-348:22::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | not (notEmpty v)\n                                                  && len v == 0} | VV == []}"
349:20-349:25::lq_anf$##7205759403792801101 :: "{v : [[a]] | not (notEmpty v)\n             && len v == 0}"
349:21-349:24::lq_anf$##7205759403792801100 :: "{v : [a] | notEmpty v\n           && head v == x}"
349:22-349:23::x :: "{VV : a | VV == x}"
351:5-351:6::x :: "{VV : a | VV == x}"
351:10-351:11::y :: "{VV : a | VV == y}"
351:20-351:25::lq_anf$##7205759403792801110 :: "{v : [a] | notEmpty v\n           && head v == x\n           && len v == 1 + len s\n           && tail v == s}"
351:21-351:22::x :: "{VV : a | VV == x}"
351:23-351:24::s :: "{v : [a] | v == s\n           && len v >= 0}"
351:28-351:30::ss :: "{v : [[a]] | v == ss\n             && len v >= 0}"
352:20-352:23::lq_anf$##7205759403792801108 :: "{v : [a] | notEmpty v\n           && head v == x}"
352:21-352:22::x :: "{VV : a | VV == x}"
352:26-352:34::lq_anf$##7205759403792801109 :: "{v : [[a]] | notEmpty v\n             && head v == s\n             && len v == 1 + len ss\n             && tail v == ss}"
352:27-352:28::s :: "{v : [a] | v == s\n           && len v >= 0}"
352:31-352:33::ss :: "{v : [[a]] | v == ss\n             && len v >= 0}"
354:8-354:9::s :: "{VV : [a] | len VV >= 0}"
354:11-354:13::ss :: "{VV : [[a]] | len VV >= 0}"
354:20-354:29::_ :: "{VV : forall a .\n      {v : [a] | notEmpty v} -> (a, [a]) | VV == safeSplit}"
354:32-354:46::lq_anf$##7205759403792801104 :: "[[a]]"
354:39-354:46::lq_anf$##7205759403792801103 :: "{v : [a] | notEmpty v\n           && head v == y\n           && len v == 1 + len etc\n           && tail v == etc}"
354:40-354:41::y :: "{VV : a | VV == y}"
354:42-354:45::etc :: "{v : [a] | v == etc\n           && len v >= 0}"
357:1-357:10::safeSplit :: "forall a . {VV : [a] | notEmpty VV} -> (a, [a])"
357:20-357:27::(,) :: "{VV : forall a b <p2 :: a b -> Bool>.\n      x1:a -> x2:{VV : b<p2 x1> | true} -> {v : (a, b)<\\x5 VV -> {VV : b<p2 x5> | true}> | fst v == x1\n                                                                                           && snd v == x2\n                                                                                           && x_Tuple21 v == x1\n                                                                                           && x_Tuple22 v == x2} | VV == (,)}"
357:21-357:22::x :: "{VV : a | VV == x}"
357:24-357:26::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
358:20-358:47::die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
358:24-358:47::lq_anf$##7205759403792801096 :: "[GHC.Types.Char]"