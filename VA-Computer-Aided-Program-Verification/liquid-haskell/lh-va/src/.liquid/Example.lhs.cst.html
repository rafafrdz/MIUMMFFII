<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>/home/ricardo/docencia/verifAsistid/2021-22/versionProfesor/LiquidHaskell/lh-tests/src/Example.lhs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types

Boolean Measures {#boolmeasures}
================


In the last two chapters, we saw how refinements could be used to
reason about the properties of basic `Int` values like vector
indices, or the elements of a list. Next, lets see how we can
describe properties of aggregate structures like lists and trees,
and use these properties to improve the APIs for operating over
such structures.

\begin{comment}
\begin{code}
<pre><span class=hs-linenum>15: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>16: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--short-names"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>17: </span>
<span class=hs-linenum>18: </span>
<span class=hs-linenum>19: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Example</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>20: </span>
<span class=hs-linenum>21: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span><span class='hs-layout'>(</span><span class='hs-varid'>foldl</span><span class='hs-layout'>,</span> <span class='hs-varid'>foldl1</span><span class='hs-layout'>,</span> <span class='hs-varid'>map</span><span class='hs-layout'>,</span> <span class='hs-varid'>sum</span><span class='hs-layout'>,</span> <span class='hs-varid'>head</span><span class='hs-layout'>,</span> <span class='hs-varid'>tail</span><span class='hs-layout'>,</span> <span class='hs-varid'>null</span><span class='hs-layout'>)</span>
<span class=hs-linenum>22: </span>
<span class=hs-linenum>23: </span><a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-definition'>main</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>putStrLn</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##592 : [GHC.Types.Char] | len lq_tmp$x##592 == strLen lq_anf$##7205759403792801054##d1We
                                    &amp;&amp; lq_tmp$x##592 ~~ lq_anf$##7205759403792801054##d1We}</span><span class='hs-str'>"Hello"</span></a>
<span class=hs-linenum>24: </span>
<span class=hs-linenum>25: </span><span class='hs-comment'>-- | Old Definitions</span>
<span class=hs-linenum>26: </span>
<span class=hs-linenum>27: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Nat</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>0</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>28: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Pos</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>0</span> <span class='hs-varop'>&lt;</span>  <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>29: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>NonZero</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>0</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>30: </span>
<span class=hs-linenum>31: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>die</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{v:</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>| false}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>32: </span><a class=annot href="#"><span class=annottext>forall a . lq_tmp$x##615:{v : [GHC.Types.Char] | false} -&gt; a</span><span class='hs-definition'>die</span></a> <a class=annot href="#"><span class=annottext>{VV##623 : [{VV##618 : GHC.Types.Char | $k_##619}]&lt;\lq_tmp$x##620 VV -&gt; {VV##621 : GHC.Types.Char | $k_##622}&gt; | $k_##624}</span><span class='hs-varid'>msg</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##894 : [{lq_tmp$x##891 : GHC.Types.Char | $k_##619[VV##618:=lq_tmp$x##891][VV##623:=lq_tmp$x##894]}]&lt;\lq_tmp$x##895 VV -&gt; {lq_tmp$x##893 : GHC.Types.Char | $k_##622[VV##621:=lq_tmp$x##893][VV##623:=lq_tmp$x##894][lq_tmp$x##620:=lq_tmp$x##895][lq_tmp$x##892:=lq_tmp$x##895]}&gt; | lq_tmp$x##894 == msg##a1iu
                                                                                                                                                                                                                                                                                               &amp;&amp; len lq_tmp$x##894 &gt;= 0
                                                                                                                                                                                                                                                                                               &amp;&amp; $k_##624[VV##623:=lq_tmp$x##894]}</span><span class='hs-varid'>msg</span></a>
<span class=hs-linenum>33: </span>
<span class=hs-linenum>34: </span><span class='hs-comment'>-- Type Definitions</span>
<span class=hs-linenum>35: </span><span class='hs-definition'>divide</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>36: </span><span class='hs-definition'>size1</span><span class='hs-layout'>,</span> <span class='hs-varid'>size2</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
</pre>\end{code}
\end{comment}


Partial Functions
------------------

As a motivating example, let us return to the problem of ensuring
the safety of division. Recall that we wrote:

\begin{code}
<pre><span class=hs-linenum>48: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>divide</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NonZero</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>49: </span><a class=annot href="#"><span class=annottext>lq_tmp$x##900:GHC.Types.Int -&gt; lq_tmp$x##901:{VV##0 : GHC.Types.Int | 0 /= VV##0} -&gt; GHC.Types.Int</span><span class='hs-definition'>divide</span></a> <span class='hs-keyword'>_</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##958:{lq_tmp$x##954 : [GHC.Types.Char] | false} -&gt; a | VV == Example.die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##945 : [GHC.Types.Char] | len lq_tmp$x##945 == strLen lq_anf$##7205759403792801079##d1WD
                                    &amp;&amp; lq_tmp$x##945 ~~ lq_anf$##7205759403792801079##d1WD}</span><span class='hs-str'>"divide-by-zero"</span></a>
<span class=hs-linenum>50: </span><span class='hs-definition'>divide</span> <span class='hs-varid'>x</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##935 : GHC.Types.Int | lq_tmp$x##935 == ds_d1TB}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>`div`</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##936 : GHC.Types.Int | lq_tmp$x##936 == ds_d1TC
                                 &amp;&amp; 0 /= lq_tmp$x##936}</span><span class='hs-varid'>n</span></a>
</pre>\end{code}

\newthought{The Precondition} asserted by the input type `NonZero`
allows LiquidHaskell to prove that the `die` is *never* executed at
run-time, but consequently, requires us to establish that wherever
`divide` is *used*, the second parameter be provably non-zero.
This requirement is not onerous when we know what the
divisor is *statically*

\begin{code}
<pre><span class=hs-linenum>61: </span><a class=annot href="#"><span class=annottext>lq_tmp$x##970:GHC.Types.Int -&gt; lq_tmp$x##971:GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-definition'>avg2</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>divide</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##985 : GHC.Types.Int | lq_tmp$x##985 == x##a1nb + y##a1nc}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##988 : GHC.Types.Int | lq_tmp$x##988 == x##a1nb}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##989 : GHC.Types.Int | lq_tmp$x##989 == y##a1nc}</span><span class='hs-varid'>y</span></a><span class='hs-layout'>)</span>     <a class=annot href="#"><span class=annottext>{lq_tmp$x##994 : GHC.Types.Int | lq_tmp$x##994 == (lq_anf$##7205759403792801082##d1WG : int)}</span><span class='hs-num'>2</span></a>
<span class=hs-linenum>62: </span>
<span class=hs-linenum>63: </span><a class=annot href="#"><span class=annottext>lq_tmp$x##1010:GHC.Types.Int -&gt; lq_tmp$x##1011:GHC.Types.Int -&gt; lq_tmp$x##1012:GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-definition'>avg3</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>z</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>divide</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1044 : GHC.Types.Int | lq_tmp$x##1044 == lq_anf$##7205759403792801084##d1WI + z##a1of}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##1030 : GHC.Types.Int | lq_tmp$x##1030 == x##a1od}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1031 : GHC.Types.Int | lq_tmp$x##1031 == y##a1oe}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1048 : GHC.Types.Int | lq_tmp$x##1048 == z##a1of}</span><span class='hs-varid'>z</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1053 : GHC.Types.Int | lq_tmp$x##1053 == (lq_anf$##7205759403792801086##d1WK : int)}</span><span class='hs-num'>3</span></a>
</pre>\end{code}

\noindent However, it can be more of a challenge when the divisor
is obtained *dynamically*. For example, lets write a function to
find the number of elements in a list

\begin{code}
<pre><span class=hs-linenum>71: </span><span class='hs-definition'>size</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>72: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2414:[a] -&gt; {VV##0 : GHC.Types.Int | (Example.notEmpty lq_tmp$x##2414 =&gt; VV##0 &gt; 0)
                                               &amp;&amp; VV##0 &gt;= 0}</span><span class='hs-definition'>size</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{lq_tmp$x##2440 : GHC.Prim.Int# | lq_tmp$x##2440 == 0}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>73: </span><span class='hs-definition'>size</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{lq_tmp$x##2486 : GHC.Types.Int | lq_tmp$x##2486 == (lq_anf$##7205759403792801113##d1Xb : int)}</span><span class='hs-num'>1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2495 : GHC.Types.Int | (Example.notEmpty xs##a1og =&gt; lq_tmp$x##2495 &gt; 0)
                                  &amp;&amp; lq_tmp$x##2495 &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2506 : [a] | lq_tmp$x##2506 == xs##a1og
                        &amp;&amp; len lq_tmp$x##2506 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\noindent and use it to compute the average value of a list:

\begin{code}
<pre><span class=hs-linenum>79: </span><a class=annot href="#"><span class=annottext>lq_tmp$x##3821:[GHC.Types.Int] -&gt; GHC.Types.Int</span><span class='hs-definition'>avgMany</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Int]</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3869:GHC.Types.Int -&gt; lq_tmp$x##3870:{lq_tmp$x##3865 : GHC.Types.Int | 0 /= lq_tmp$x##3865} -&gt; GHC.Types.Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3871 : GHC.Types.Int | lq_tmp$x##3871 == total##a1oi}</span><span class='hs-varid'>total</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{lq_tmp$x##3872 : GHC.Types.Int | (Example.notEmpty xs##a1oh =&gt; lq_tmp$x##3872 &gt; 0)
                                  &amp;&amp; lq_tmp$x##3872 == elems##a1oj
                                  &amp;&amp; lq_tmp$x##3872 &gt;= 0}</span><span class='hs-varid'>elems</span></a></span>
<span class=hs-linenum>80: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>81: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>total</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>sum</span></a>  <span class=hs-error><a class=annot href="#"><span class=annottext>{lq_tmp$x##3861 : [GHC.Types.Int] | lq_tmp$x##3861 == xs##a1oh
                                    &amp;&amp; len lq_tmp$x##3861 &gt;= 0}</span><span class='hs-varid'>xs</span></a></span>
<span class=hs-linenum>82: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp$x##3828 : GHC.Types.Int | (Example.notEmpty xs##a1oh =&gt; lq_tmp$x##3828 &gt; 0)
                                  &amp;&amp; lq_tmp$x##3828 &gt;= 0}</span><span class='hs-varid'>elems</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2414:[a] -&gt; {VV##0 : GHC.Types.Int | (Example.notEmpty lq_tmp$x##2414 =&gt; VV##0 &gt; 0)
                                               &amp;&amp; VV##0 &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3839 : [GHC.Types.Int] | lq_tmp$x##3839 == xs##a1oh
                                    &amp;&amp; len lq_tmp$x##3839 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

Uh oh. LiquidHaskell wags its finger at us!

~~~~~{.liquiderror}
     src/04-measure.lhs:77:27-31: Error: Liquid Type Mismatch
       Inferred type
         VV : Int | VV == elems

       not a subtype of Required type
         VV : Int | 0 /= VV

       In Context
         VV    : Int | VV == elems
         elems : Int
~~~~~

\newthought{We cannot prove} that the divisor is `NonZero`,
because it *can be* `0` -- when the list is *empty*. Thus, we
need a way of specifying that the input to `avgMany` is indeed
non-empty!

Lifting Functions to Measures {#usingmeasures}
-----------------------------

\newthought{How} shall we tell LiquidHaskell that a list is *non-empty*?
Recall the notion of `measure` previously [introduced](#vectorbounds)
to describe the size of a `Data.Vector`. In that spirit, lets write
a function that computes whether a list is not empty:

\begin{code}
<pre><span class=hs-linenum>114: </span><span class='hs-definition'>notEmpty</span>       <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>115: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2526:[a] -&gt; {VV : GHC.Types.Bool | VV &lt;=&gt; Example.notEmpty lq_tmp$x##2526}</span><span class='hs-definition'>notEmpty</span></a> <span class='hs-conid'>[]</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2551 : GHC.Types.Bool | not lq_tmp$x##2551
                                   &amp;&amp; lq_tmp$x##2551 == GHC.Types.False}</span><span class='hs-conid'>False</span></a>
<span class=hs-linenum>116: </span><span class='hs-definition'>notEmpty</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2588 : GHC.Types.Bool | lq_tmp$x##2588
                                   &amp;&amp; lq_tmp$x##2588 == GHC.Types.True}</span><span class='hs-conid'>True</span></a>
</pre>\end{code}

\newthought{A measure} is a *total* Haskell function,

1. With a *single* equation per data constructor, and
2. Guaranteed to *terminate*, typically via structural recursion.

\noindent
We can tell LiquidHaskell to *lift* a function meeting
the above requirements into the refinement logic by declaring:

\begin{code}
<pre><span class=hs-linenum>129: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>notEmpty</span> <span class='hs-keyword'>@-}</span>
</pre>\end{code}


\newthought{Non-Empty Lists} can now be described as
the *subset* of plain old Haskell lists `[a]` for which
the predicate `notEmpty` holds

\begin{code}
<pre><span class=hs-linenum>138: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>notEmpty</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>\end{code}

We can now refine various signatures to establish the safety of
the list-average function.

\newthought{Size} returns a non-zero value *if* the input list is
not-empty. We capture this condition with an [implication](#semantics)
in the output refinement.

\begin{code}
<pre><span class=hs-linenum>149: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| notEmpty xs =&gt; v &gt; 0}</span> <span class='hs-keyword'>@-}</span>
</pre>\end{code}

\newthought{Average} is only sensible for non-empty lists.
Happily, we can specify this using the refined `NEList` type:

\begin{code}
<pre><span class=hs-linenum>156: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>average</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>157: </span><a class=annot href="#"><span class=annottext>lq_tmp$x##3875:{VV##0 : [GHC.Types.Int] | Example.notEmpty VV##0} -&gt; GHC.Types.Int</span><span class='hs-definition'>average</span></a> <a class=annot href="#"><span class=annottext>{VV##0 : [GHC.Types.Int] | Example.notEmpty VV##0}</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3923:GHC.Types.Int -&gt; lq_tmp$x##3924:{lq_tmp$x##3919 : GHC.Types.Int | 0 /= lq_tmp$x##3919} -&gt; GHC.Types.Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3925 : GHC.Types.Int | lq_tmp$x##3925 == total##a1ol}</span><span class='hs-varid'>total</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3926 : GHC.Types.Int | (Example.notEmpty xs##a1ok =&gt; lq_tmp$x##3926 &gt; 0)
                                  &amp;&amp; lq_tmp$x##3926 == elems##a1om
                                  &amp;&amp; lq_tmp$x##3926 &gt;= 0}</span><span class='hs-varid'>elems</span></a>
<span class=hs-linenum>158: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>159: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>total</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>sum</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3915 : [GHC.Types.Int] | Example.notEmpty lq_tmp$x##3915
                                    &amp;&amp; lq_tmp$x##3915 == xs##a1ok
                                    &amp;&amp; len lq_tmp$x##3915 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>160: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp$x##3882 : GHC.Types.Int | (Example.notEmpty xs##a1ok =&gt; lq_tmp$x##3882 &gt; 0)
                                  &amp;&amp; lq_tmp$x##3882 &gt;= 0}</span><span class='hs-varid'>elems</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2414:[a] -&gt; {VV##0 : GHC.Types.Int | (Example.notEmpty lq_tmp$x##2414 =&gt; VV##0 &gt; 0)
                                               &amp;&amp; VV##0 &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3893 : [GHC.Types.Int] | Example.notEmpty lq_tmp$x##3893
                                    &amp;&amp; lq_tmp$x##3893 == xs##a1ok
                                    &amp;&amp; len lq_tmp$x##3893 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

<div class="hwex" id="Average, Maybe">
Fix the code below to obtain an alternate variant
`average'` that returns `Nothing` for empty lists:
</div>

\begin{code}
<pre><span class=hs-linenum>169: </span><span class='hs-definition'>average'</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>170: </span><a class=annot href="#"><span class=annottext>lq_tmp$x##3929:[GHC.Types.Int] -&gt; (GHC.Maybe.Maybe GHC.Types.Int)</span><span class='hs-definition'>average'</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Int]</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>171: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ok</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##3989:a -&gt; {lq_tmp$x##3987 : (GHC.Maybe.Maybe a) | isJust lq_tmp$x##3987
                                                                  &amp;&amp; fromJust lq_tmp$x##3987 == lq_tmp$x##3989} | VV == GHC.Maybe.Just}</span><span class='hs-conid'>Just</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>sum</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4013 : [GHC.Types.Int] | lq_tmp$x##4013 == xs##a1on
                                    &amp;&amp; len lq_tmp$x##4013 &gt;= 0}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4024 : GHC.Types.Int | (Example.notEmpty xs##a1on =&gt; lq_tmp$x##4024 &gt; 0)
                                  &amp;&amp; lq_tmp$x##4024 == elems##a1oo
                                  &amp;&amp; lq_tmp$x##4024 &gt;= 0}</span><span class='hs-varid'>elems</span></a>
<span class=hs-linenum>172: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      {lq_tmp$x##3976 : (GHC.Maybe.Maybe a) | not (isJust lq_tmp$x##3976)} | VV == GHC.Maybe.Nothing}</span><span class='hs-conid'>Nothing</span></a>
<span class=hs-linenum>173: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>174: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp$x##3936 : GHC.Types.Int | (Example.notEmpty xs##a1on =&gt; lq_tmp$x##3936 &gt; 0)
                                  &amp;&amp; lq_tmp$x##3936 &gt;= 0}</span><span class='hs-varid'>elems</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2414:[a] -&gt; {VV##0 : GHC.Types.Int | (Example.notEmpty lq_tmp$x##2414 =&gt; VV##0 &gt; 0)
                                               &amp;&amp; VV##0 &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3947 : [GHC.Types.Int] | lq_tmp$x##3947 == xs##a1on
                                    &amp;&amp; len lq_tmp$x##3947 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>175: </span>    <span class='hs-varid'>ok</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3954 : GHC.Types.Bool | lq_tmp$x##3954 &lt;=&gt; Example.notEmpty xs##a1on}</span><span class='hs-varid'>notEmpty</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3965 : [GHC.Types.Int] | lq_tmp$x##3965 == xs##a1on
                                    &amp;&amp; len lq_tmp$x##3965 &gt;= 0}</span><span class='hs-varid'>xs</span></a>   <span class='hs-comment'>-- What expression goes here?</span>
</pre>\end{code}

<div class="hwex" id="Debugging Specifications">
An important aspect of formal verifiers like LiquidHaskell
is that they help establish properties not just of your *implementations*
but equally, or more importantly, of your *specifications*. In that spirit,
can you explain why the following two variants of `size` are *rejected*
by LiquidHaskell?
</div>

\begin{code}
<pre><span class=hs-linenum>187: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size1</span>    <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Pos</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>188: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2591:{VV##0 : [a] | Example.notEmpty VV##0} -&gt; {VV##0 : GHC.Types.Int | 0 &lt; VV##0}</span><span class='hs-definition'>size1</span></a> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span>    <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{lq_tmp$x##2688 : GHC.Prim.Int# | lq_tmp$x##2688 == 1}</span><span class='hs-num'>1</span></a>
<span class=hs-linenum>189: </span><span class='hs-definition'>size1</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{lq_tmp$x##2734 : GHC.Types.Int | lq_tmp$x##2734 == (lq_anf$##7205759403792801120##d1Xi : int)}</span><span class='hs-num'>1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2743 : GHC.Types.Int | 0 &lt; lq_tmp$x##2743}</span><span class='hs-varid'>size1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2754 : [a] | lq_tmp$x##2754 == ds_d1SK
                        &amp;&amp; len lq_tmp$x##2754 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>190: </span>
<span class=hs-linenum>191: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size2</span>    <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| notEmpty xs =&gt; v &gt; 0}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>192: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2774:[a] -&gt; {v : GHC.Types.Int | Example.notEmpty lq_tmp$x##2774 =&gt; v &gt; 0}</span><span class='hs-definition'>size2</span></a> <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{lq_tmp$x##2799 : GHC.Prim.Int# | lq_tmp$x##2799 == 0}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>193: </span><span class='hs-definition'>size2</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2591:{VV##0 : [a] | Example.notEmpty VV##0} -&gt; {VV##0 : GHC.Types.Int | 0 &lt; VV##0}</span><span class='hs-varid'>size1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2857 : [a] | lq_tmp$x##2857 == ds_d1SP
                        &amp;&amp; len lq_tmp$x##2857 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}


A Safe List API
---------------

Now that we can talk about non-empty lists, we can ensure
the safety of various list-manipulating functions which
are only well-defined on non-empty lists and crash otherwise.

\newthought{Head and Tail} are two of the canonical *dangerous*
functions, that only work on non-empty lists, and burn horribly
otherwise. We can type them simple as:


\begin{code}
<pre><span class=hs-linenum>210: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>head</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>211: </span><a class=annot href="#"><span class=annottext>forall p .
lq_tmp$x##1072:{VV##0 : [p] | Example.notEmpty VV##0} -&gt; p</span><span class='hs-definition'>head</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1162 : p | lq_tmp$x##1162 == x##a1os}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>212: </span><span class='hs-definition'>head</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##1116:{lq_tmp$x##1112 : [GHC.Types.Char] | false} -&gt; a | VV == Example.die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1103 : [GHC.Types.Char] | len lq_tmp$x##1103 == strLen lq_anf$##7205759403792801089##d1WN
                                     &amp;&amp; lq_tmp$x##1103 ~~ lq_anf$##7205759403792801089##d1WN}</span><span class='hs-str'>"Fear not! 'twill ne'er come to pass"</span></a>
<span class=hs-linenum>213: </span>
<span class=hs-linenum>214: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>tail</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>215: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1165:{VV##0 : [a] | Example.notEmpty VV##0} -&gt; [a]</span><span class='hs-definition'>tail</span></a> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1267 : [a] | lq_tmp$x##1267 == xs##a1ot
                        &amp;&amp; len lq_tmp$x##1267 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>216: </span><span class='hs-definition'>tail</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##1210:{lq_tmp$x##1206 : [GHC.Types.Char] | false} -&gt; a | VV == Example.die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1197 : [GHC.Types.Char] | len lq_tmp$x##1197 == strLen lq_anf$##7205759403792801092##d1WQ
                                     &amp;&amp; lq_tmp$x##1197 ~~ lq_anf$##7205759403792801092##d1WQ}</span><span class='hs-str'>"Relaxeth! this too shall ne'er be"</span></a>
</pre>\end{code}

LiquidHaskell uses the precondition to deduce that
the second equations are *dead code*. Of course, this
requires us to establish that *callers* of `head` and `tail`
only invoke the respective functions with non-empty lists.

<div class="hwex" id="Safe Head">
Write down a specification for `null` such that `safeHead`
is verified. Do *not* force `null` to only take non-empty inputs,
that defeats the purpose. Instead, its type should say that it
works on *all* lists and returns `True` *if and only if* the input
is non-empty.
</div>

\hint You may want to refresh your memory about implies `==>`
and `<=>` from the [chapter on logic](#semantics).

\begin{code}
<pre><span class=hs-linenum>236: </span><span class='hs-definition'>safeHead</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>237: </span><a class=annot href="#"><span class=annottext>forall a . lq_tmp$x##2926:[a] -&gt; (GHC.Maybe.Maybe a)</span><span class='hs-definition'>safeHead</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>238: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2933 : GHC.Types.Bool | lq_tmp$x##2933 &lt;=&gt; not (Example.notEmpty xs##a1ou)}</span><span class='hs-varid'>null</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2944 : [a] | lq_tmp$x##2944 == xs##a1ou
                        &amp;&amp; len lq_tmp$x##2944 &gt;= 0}</span><span class='hs-varid'>xs</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      {lq_tmp$x##3015 : (GHC.Maybe.Maybe a) | not (isJust lq_tmp$x##3015)} | VV == GHC.Maybe.Nothing}</span><span class='hs-conid'>Nothing</span></a>
<span class=hs-linenum>239: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##2958:a -&gt; {lq_tmp$x##2956 : (GHC.Maybe.Maybe a) | isJust lq_tmp$x##2956
                                                                  &amp;&amp; fromJust lq_tmp$x##2956 == lq_tmp$x##2958} | VV == GHC.Maybe.Just}</span><span class='hs-conid'>Just</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2974 : a | $k_##2973[VV##2972:=lq_tmp$x##2974][lq_tmp$x##2970:=xs##a1ou]}</span><span class='hs-varid'>head</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2978 : [a] | lq_tmp$x##2978 == xs##a1ou
                        &amp;&amp; len lq_tmp$x##2978 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>240: </span>
<span class=hs-linenum>241: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>null</span>      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{b:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| b &lt;=&gt; not (notEmpty xs)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>242: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2861:[a] -&gt; {b : GHC.Types.Bool | b &lt;=&gt; not (Example.notEmpty lq_tmp$x##2861)}</span><span class='hs-definition'>null</span></a> <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{lq_tmp$x##2886 : GHC.Types.Bool | lq_tmp$x##2886
                                   &amp;&amp; lq_tmp$x##2886 == GHC.Types.True}</span><span class='hs-conid'>True</span></a>
<span class=hs-linenum>243: </span><span class='hs-definition'>null</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{lq_tmp$x##2923 : GHC.Types.Bool | not lq_tmp$x##2923
                                   &amp;&amp; lq_tmp$x##2923 == GHC.Types.False}</span><span class='hs-conid'>False</span></a>
</pre>\end{code}

\newthought{Groups}
Lets use the above to write a function that chunks sequences
into non-empty groups of equal elements:

\begin{code}
<pre><span class=hs-linenum>251: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>groupEq</span>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>252: </span><a class=annot href="#"><span class=annottext>forall a .
(Eq&lt;[]&gt; a) =&gt;
lq_tmp$x##3022:[a] -&gt; [{VV##0 : [a] | Example.notEmpty VV##0}]</span><span class='hs-definition'>groupEq</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {lq_tmp$x##3055 : [a]&lt;\lq_tmp$x##3056 VV -&gt; {lq_tmp$x##3054 : a&lt;p lq_tmp$x##3056&gt; | true}&gt; | not (Example.notEmpty lq_tmp$x##3055)
                                                                                                   &amp;&amp; len lq_tmp$x##3055 == 0} | VV == GHC.Types.[]}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>253: </span><span class='hs-definition'>groupEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3300 : [{lq_tmp$x##3310 : a | $k_##3309[VV##3308:=lq_tmp$x##3310][lq_tmp$x##3304:=x##a1ov][lq_tmp$x##3305:=ys##a1va]}]&lt;\lq_tmp$x##3307 VV -&gt; {lq_tmp$x##3310 : a | $k_##3312[VV##3311:=lq_tmp$x##3310][lq_tmp$x##3304:=x##a1ov][lq_tmp$x##3305:=ys##a1va][lq_tmp$x##3313:=lq_tmp$x##3307]}&gt; | Example.notEmpty lq_tmp$x##3300
                                                                                                                                                                                                                                                                                                         &amp;&amp; head lq_tmp$x##3300 == x##a1ov
                                                                                                                                                                                                                                                                                                         &amp;&amp; len lq_tmp$x##3300 == 1 + len ys##a1va
                                                                                                                                                                                                                                                                                                         &amp;&amp; tail lq_tmp$x##3300 == ys##a1va}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##3315 : a | lq_tmp$x##3315 == x##a1ov}</span><span class='hs-varid'>x</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{lq_tmp$x##3319 : [{lq_tmp$x##3316 : a | $k_##3181[VV##3180:=lq_tmp$x##3316][VV##3185:=lq_tmp$x##3319]}]&lt;\lq_tmp$x##3320 VV -&gt; {lq_tmp$x##3318 : a | $k_##3184[VV##3183:=lq_tmp$x##3318][VV##3185:=lq_tmp$x##3319][lq_tmp$x##3182:=lq_tmp$x##3320][lq_tmp$x##3317:=lq_tmp$x##3320]}&gt; | lq_tmp$x##3319 == ys##a1va
                                                                                                                                                                                                                                                                                       &amp;&amp; len lq_tmp$x##3319 &gt;= 0
                                                                                                                                                                                                                                                                                       &amp;&amp; $k_##3186[VV##3185:=lq_tmp$x##3319]}</span><span class='hs-varid'>ys</span></a><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>[{lq_tmp$x##3331 : [{lq_tmp$x##3349 : a | $k_##3348[VV##3347:=lq_tmp$x##3349][lq_tmp$x##3341:=fix$36$$36$dEq_a1xv][lq_tmp$x##3342:=zs##a1vc]}] | Example.notEmpty lq_tmp$x##3331}]</span><span class='hs-varid'>groupEq</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3355 : [{lq_tmp$x##3352 : a | $k_##3237[VV##3236:=lq_tmp$x##3352][VV##3241:=lq_tmp$x##3355]}]&lt;\lq_tmp$x##3356 VV -&gt; {lq_tmp$x##3354 : a | $k_##3240[VV##3239:=lq_tmp$x##3354][VV##3241:=lq_tmp$x##3355][lq_tmp$x##3238:=lq_tmp$x##3356][lq_tmp$x##3353:=lq_tmp$x##3356]}&gt; | lq_tmp$x##3355 == zs##a1vc
                                                                                                                                                                                                                                                                                       &amp;&amp; len lq_tmp$x##3355 &gt;= 0
                                                                                                                                                                                                                                                                                       &amp;&amp; $k_##3242[VV##3241:=lq_tmp$x##3355]}</span><span class='hs-varid'>zs</span></a>
<span class=hs-linenum>254: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>255: </span>    <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV##3185 : [{VV##3180 : a | $k_##3181}]&lt;\lq_tmp$x##3182 VV -&gt; {VV##3183 : a | $k_##3184}&gt; | $k_##3186}</span><span class='hs-varid'>ys</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV##3241 : [{VV##3236 : a | $k_##3237}]&lt;\lq_tmp$x##3238 VV -&gt; {VV##3239 : a | $k_##3240}&gt; | $k_##3242}</span><span class='hs-varid'>zs</span></a><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>ds_d1RT:{VV##3113 : a | $k_##3114} -&gt; {lq_tmp$x##3120 : GHC.Types.Bool | lq_tmp$x##3120 &lt;=&gt; x##a1ov == ds_d1RT}</span><span class='hs-varid'>span</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3120 : GHC.Types.Bool | lq_tmp$x##3120 &lt;=&gt; x##a1ov == ds_d1RT}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##3132 : a | lq_tmp$x##3132 == x##a1ov}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>==</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3177 : [a] | lq_tmp$x##3177 == xs##a1ow
                        &amp;&amp; len lq_tmp$x##3177 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\noindent By using the fact that *each element* in the
output returned by `groupEq` is in fact of the form `x:ys`,
LiquidHaskell infers that `groupEq` returns a `[NEList a]`
that is, a list of *non-empty lists*.

\newthought{To Eliminate Stuttering} from a string, we can use `groupEq`
to split the string into blocks of repeating `Char`s, and then just
extract the first `Char` from each block:

\begin{code}
<pre><span class=hs-linenum>268: </span><span class='hs-comment'>-- &gt;&gt;&gt; eliminateStutter "ssstringssss liiiiiike thisss"</span>
<span class=hs-linenum>269: </span><span class='hs-comment'>-- "strings like this"</span>
<span class=hs-linenum>270: </span><a class=annot href="#"><span class=annottext>forall a . (Eq&lt;[]&gt; a) =&gt; lq_tmp$x##4438:[a] -&gt; [a]</span><span class='hs-definition'>eliminateStutter</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##4472:[{lq_tmp$x##4485 : [{lq_tmp$x##4482 : a | $k_##4476[VV##4475:=lq_tmp$x##4482][VV##4480:=lq_tmp$x##4485][lq_tmp$x##4471:=lq_anf$##7205759403792801168##d1Y4]}]&lt;\lq_tmp$x##4483 VV -&gt; {lq_tmp$x##4484 : a | $k_##4479[VV##4478:=lq_tmp$x##4484][VV##4480:=lq_tmp$x##4485][lq_tmp$x##4471:=lq_anf$##7205759403792801168##d1Y4][lq_tmp$x##4477:=lq_tmp$x##4483]}&gt; | $k_##4481[VV##4480:=lq_tmp$x##4485][lq_tmp$x##4471:=lq_anf$##7205759403792801168##d1Y4]}] -&gt; {lq_tmp$x##4466 : [{lq_tmp$x##4488 : a | $k_##4487[VV##4486:=lq_tmp$x##4488][lq_tmp$x##4471:=lq_anf$##7205759403792801168##d1Y4]}] | Example.notEmpty lq_tmp$x##4472 &lt;=&gt; Example.notEmpty lq_tmp$x##4466}</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>{VV : forall p .
      lq_tmp$x##4450:{lq_tmp$x##4446 : [p] | Example.notEmpty lq_tmp$x##4446} -&gt; p | VV == Example.head}</span><span class='hs-varid'>head</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>[{lq_tmp$x##4508 : [{lq_tmp$x##4526 : a | $k_##4525[VV##4524:=lq_tmp$x##4526][lq_tmp$x##4518:=fix$36$$36$dEq_a1FZ][lq_tmp$x##4519:=xs##a1q8]}] | Example.notEmpty lq_tmp$x##4508}]</span><span class='hs-varid'>groupEq</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4532 : [a] | lq_tmp$x##4532 == xs##a1q8
                        &amp;&amp; len lq_tmp$x##4532 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\noindent
LiquidHaskell automatically instantiates the type parameter
for `map` in `eliminateStutter` to `notEmpty v` to deduce that
`head` is only called on non-empty lists.

\newthought{Foldl1} is one of my favorite folds; it uses
the first element of the sequence as the initial value.
Of course, it should only be called with non-empty sequences!

\begin{code}
<pre><span class=hs-linenum>283: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>foldl1</span>         <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>284: </span><a class=annot href="#"><span class=annottext>forall p .
lq_tmp$x##3541:(lq_tmp$x##3538:p -&gt; lq_tmp$x##3539:p -&gt; p) -&gt; lq_tmp$x##3542:{VV##0 : [p] | Example.notEmpty VV##0} -&gt; p</span><span class='hs-definition'>foldl1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##3538:p -&gt; lq_tmp$x##3539:p -&gt; p</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3416:(lq_tmp$x##3413:a -&gt; lq_tmp$x##3414:b -&gt; a) -&gt; lq_tmp$x##3417:a -&gt; lq_tmp$x##3418:[b] -&gt; a</span><span class='hs-varid'>foldl</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##3665:p -&gt; lq_tmp$x##3666:p -&gt; p</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3667 : p | lq_tmp$x##3667 == x##a1qa}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3671 : [p] | lq_tmp$x##3671 == xs##a1qb
                        &amp;&amp; len lq_tmp$x##3671 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>285: </span><span class='hs-definition'>foldl1</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##3587:{lq_tmp$x##3583 : [GHC.Types.Char] | false} -&gt; a | VV == Example.die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3574 : [GHC.Types.Char] | len lq_tmp$x##3574 == strLen lq_anf$##7205759403792801140##d1XC
                                     &amp;&amp; lq_tmp$x##3574 ~~ lq_anf$##7205759403792801140##d1XC}</span><span class='hs-str'>"foldl1"</span></a>
<span class=hs-linenum>286: </span>
<span class=hs-linenum>287: </span><span class='hs-definition'>foldl</span>              <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>288: </span><a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3416:(lq_tmp$x##3413:a -&gt; lq_tmp$x##3414:b -&gt; a) -&gt; lq_tmp$x##3417:a -&gt; lq_tmp$x##3418:[b] -&gt; a</span><span class='hs-definition'>foldl</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>acc</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3446 : a | lq_tmp$x##3446 == acc##a1qc}</span><span class='hs-varid'>acc</span></a>
<span class=hs-linenum>289: </span><span class='hs-definition'>foldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>acc</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3416:(lq_tmp$x##3413:a -&gt; lq_tmp$x##3414:b -&gt; a) -&gt; lq_tmp$x##3417:a -&gt; lq_tmp$x##3418:[b] -&gt; a</span><span class='hs-varid'>foldl</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##3525:a -&gt; lq_tmp$x##3526:b -&gt; a</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-layout'>(</span></a><span class='hs-varid'>f</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3490 : a | lq_tmp$x##3490 == acc##a1qc}</span><span class='hs-varid'>acc</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3491 : b | lq_tmp$x##3491 == x##a1qf}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3531 : [b] | lq_tmp$x##3531 == xs##a1qg
                        &amp;&amp; len lq_tmp$x##3531 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\newthought{To Sum} a non-empty list of numbers, we can just
perform a `foldl1` with the `+` operator:
Thanks to the precondition, LiquidHaskell will prove that
the `die` code is indeed dead. Thus, we can write

\begin{code}
<pre><span class=hs-linenum>298: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>sum</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>299: </span><a class=annot href="#"><span class=annottext>forall p .
(Num&lt;[]&gt; p) =&gt;
lq_tmp$x##3679:{VV##0 : [p] | Example.notEmpty VV##0} -&gt; p</span><span class='hs-definition'>sum</span></a> <span class='hs-conid'>[]</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##3724:{lq_tmp$x##3720 : [GHC.Types.Char] | false} -&gt; a | VV == Example.die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3711 : [GHC.Types.Char] | len lq_tmp$x##3711 == strLen lq_anf$##7205759403792801144##d1XG
                                     &amp;&amp; lq_tmp$x##3711 ~~ lq_anf$##7205759403792801144##d1XG}</span><span class='hs-str'>"cannot add up empty list"</span></a>
<span class=hs-linenum>300: </span><span class='hs-definition'>sum</span> <span class='hs-varid'>xs</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall p .
      lq_tmp$x##3800:(lq_tmp$x##3797:p -&gt; lq_tmp$x##3798:p -&gt; p) -&gt; lq_tmp$x##3801:{lq_tmp$x##3793 : [p] | Example.notEmpty lq_tmp$x##3793} -&gt; p | VV == Example.foldl1}</span><span class='hs-varid'>foldl1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##3779:p -&gt; lq_tmp$x##3780:p -&gt; {lq_tmp$x##3781 : p | lq_tmp$x##3781 == lq_tmp$x##3779 + lq_tmp$x##3780}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3816 : [p] | Example.notEmpty lq_tmp$x##3816
                        &amp;&amp; lq_tmp$x##3816 == ds_d1UM
                        &amp;&amp; len lq_tmp$x##3816 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\noindent Consequently, we can only invoke `sum` on non-empty lists, so:

\begin{code}
<pre><span class=hs-linenum>306: </span><a class=annot href="#"><span class=annottext>GHC.Integer.Type.Integer</span><span class='hs-definition'>sumOk</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4206 : [{lq_tmp$x##4216 : GHC.Integer.Type.Integer | $k_##4215[VV##4214:=lq_tmp$x##4216][lq_tmp$x##4210:=lq_anf$##7205759403792801153##d1XP][lq_tmp$x##4211:=lq_anf$##7205759403792801162##d1XY]}]&lt;\lq_tmp$x##4213 VV -&gt; {lq_tmp$x##4216 : GHC.Integer.Type.Integer | $k_##4218[VV##4217:=lq_tmp$x##4216][lq_tmp$x##4210:=lq_anf$##7205759403792801153##d1XP][lq_tmp$x##4211:=lq_anf$##7205759403792801162##d1XY][lq_tmp$x##4219:=lq_tmp$x##4213]}&gt; | Example.notEmpty lq_tmp$x##4206
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 &amp;&amp; head lq_tmp$x##4206 == lq_anf$##7205759403792801153##d1XP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 &amp;&amp; len lq_tmp$x##4206 == 1 + len lq_anf$##7205759403792801162##d1XY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 &amp;&amp; tail lq_tmp$x##4206 == lq_anf$##7205759403792801162##d1XY}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##4055 : GHC.Integer.Type.Integer | lq_tmp$x##4055 == 1}</span><span class='hs-num'>1</span></a><span class='hs-layout'>,</span><a class=annot href="#"><span class=annottext>{lq_tmp$x##4057 : GHC.Integer.Type.Integer | lq_tmp$x##4057 == 2}</span><span class='hs-num'>2</span></a><span class='hs-layout'>,</span><a class=annot href="#"><span class=annottext>{lq_tmp$x##4059 : GHC.Integer.Type.Integer | lq_tmp$x##4059 == 3}</span><span class='hs-num'>3</span></a><span class='hs-layout'>,</span><a class=annot href="#"><span class=annottext>{lq_tmp$x##4061 : GHC.Integer.Type.Integer | lq_tmp$x##4061 == 4}</span><span class='hs-num'>4</span></a><span class='hs-layout'>,</span><a class=annot href="#"><span class=annottext>{lq_tmp$x##4063 : GHC.Integer.Type.Integer | lq_tmp$x##4063 == 5}</span><span class='hs-num'>5</span></a><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- is accepted by LH, but</span>
<span class=hs-linenum>307: </span>
<span class=hs-linenum>308: </span><span class=hs-error><a class=annot href="#"><span class=annottext>GHC.Integer.Type.Integer</span><span class='hs-definition'>sumBad</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-keyglyph'>=</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>sum</span></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {lq_tmp$x##4253 : [a]&lt;\lq_tmp$x##4254 VV -&gt; {lq_tmp$x##4252 : a&lt;p lq_tmp$x##4254&gt; | true}&gt; | not (Example.notEmpty lq_tmp$x##4253)
                                                                                                   &amp;&amp; len lq_tmp$x##4253 == 0} | VV == GHC.Types.[]}</span><span class='hs-conid'>[]</span></a></span>             <span class='hs-comment'>-- is rejected by LH</span>
</pre>\end{code}

<div class="hwex" id="Weighted Average">
The function below computes a weighted average of its input.
Unfortunately, LiquidHaskell is not very happy about it. Can you figure out
why, and fix the code or specification appropriately?
</div>

\begin{code}
<pre><span class=hs-linenum>318: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>wtAverage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pos</span><span class='hs-layout'>,</span> <span class='hs-conid'>Pos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>319: </span><a class=annot href="#"><span class=annottext>lq_tmp$x##4627:{VV##0 : [({VV##0 : GHC.Types.Int | 0 &lt; VV##0}, {VV##0 : GHC.Types.Int | 0 &lt; VV##0})] | Example.notEmpty VV##0} -&gt; GHC.Types.Int</span><span class='hs-definition'>wtAverage</span></a> <a class=annot href="#"><span class=annottext>{VV##0 : [({VV##0 : GHC.Types.Int | 0 &lt; VV##0}, {VV##0 : GHC.Types.Int | 0 &lt; VV##0})] | Example.notEmpty VV##0}</span><span class='hs-varid'>wxs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##4954:GHC.Types.Int -&gt; lq_tmp$x##4955:{lq_tmp$x##4950 : GHC.Types.Int | 0 /= lq_tmp$x##4950} -&gt; GHC.Types.Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4956 : GHC.Types.Int | lq_tmp$x##4956 == totElems##a1ql
                                  &amp;&amp; $k_##4666[VV##4665:=lq_tmp$x##4956][lq_tmp$x##4662:=lq_anf$##7205759403792801171##d1Y7][lq_tmp$x##4663:=elems##a1qj][lq_tmp$x##4667:=lq_tmp$x##4956][lq_tmp$x##4938:=lq_tmp$x##4956][lq_tmp$x##4941:=elems##a1qj]}</span><span class='hs-varid'>totElems</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4957 : GHC.Types.Int | lq_tmp$x##4957 == totWeight##a1qm
                                  &amp;&amp; $k_##4666[VV##4665:=lq_tmp$x##4957][lq_tmp$x##4662:=lq_anf$##7205759403792801171##d1Y7][lq_tmp$x##4663:=weights##a1qk][lq_tmp$x##4667:=lq_tmp$x##4957][lq_tmp$x##4794:=lq_tmp$x##4957][lq_tmp$x##4797:=weights##a1qk]}</span><span class='hs-varid'>totWeight</span></a>
<span class=hs-linenum>320: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>321: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp$x##4882 : [{lq_tmp$x##4907 : GHC.Types.Int | $k_##4906[VV##4905:=lq_tmp$x##4907][lq_tmp$x##4887:=lq_anf$##7205759403792801175##d1Yb][lq_tmp$x##4888:=wxs##a1qi]}] | Example.notEmpty wxs##a1qi &lt;=&gt; Example.notEmpty lq_tmp$x##4882}</span><span class='hs-varid'>elems</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>ds_d1Ut:{VV##4812 : ({VV##4805 : GHC.Types.Int | $k_##4806}, {VV##4807 : GHC.Types.Int | $k_##4808})&lt;\lq_tmp$x##4809 VV -&gt; {VV##4810 : GHC.Types.Int | $k_##4811}&gt; | $k_##4813} -&gt; {VV##4815 : GHC.Types.Int | $k_##4816}</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4821 : ({lq_tmp$x##4817 : GHC.Types.Int | $k_##4806[VV##4805:=lq_tmp$x##4817][VV##4812:=lq_tmp$x##4821]}, {lq_tmp$x##4818 : GHC.Types.Int | $k_##4808[VV##4807:=lq_tmp$x##4818][VV##4812:=lq_tmp$x##4821]})&lt;\lq_tmp$x##4822 VV -&gt; {lq_tmp$x##4820 : GHC.Types.Int | $k_##4811[VV##4810:=lq_tmp$x##4820][VV##4812:=lq_tmp$x##4821][lq_tmp$x##4809:=lq_tmp$x##4822][lq_tmp$x##4819:=lq_tmp$x##4822]}&gt; | lq_tmp$x##4821 == ds_d1Ut
                                                                                                                                                                                                                                                                                                                                                                                                                 &amp;&amp; $k_##4813[VV##4812:=lq_tmp$x##4821]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4869 : GHC.Types.Int | lq_tmp$x##4869 == w##a1qo
                                  &amp;&amp; $k_##4806[VV##4805:=lq_tmp$x##4869][VV##4812:=lq_anf$##7205759403792801174##d1Ya][lq_tmp$x##4817:=lq_tmp$x##4869][lq_tmp$x##4821:=lq_anf$##7205759403792801174##d1Ya][lq_tmp$x##4824:=lq_tmp$x##4869][lq_tmp$x##4828:=lq_anf$##7205759403792801174##d1Ya]}</span><span class='hs-varid'>w</span></a> <span class='hs-varop'>*</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4870 : GHC.Types.Int | lq_tmp$x##4870 == x##a1qp
                                  &amp;&amp; $k_##4808[VV##4807:=lq_tmp$x##4870][VV##4812:=lq_anf$##7205759403792801174##d1Ya][lq_tmp$x##4818:=lq_tmp$x##4870][lq_tmp$x##4821:=lq_anf$##7205759403792801174##d1Ya][lq_tmp$x##4825:=lq_tmp$x##4870][lq_tmp$x##4828:=lq_anf$##7205759403792801174##d1Ya][lq_tmp$x##4839:=w##a1qo]
                                  &amp;&amp; $k_##4811[VV##4810:=lq_tmp$x##4870][VV##4812:=lq_anf$##7205759403792801174##d1Ya][lq_tmp$x##4809:=w##a1qo][lq_tmp$x##4819:=w##a1qo][lq_tmp$x##4820:=lq_tmp$x##4870][lq_tmp$x##4821:=lq_anf$##7205759403792801174##d1Ya][lq_tmp$x##4822:=w##a1qo][lq_tmp$x##4825:=lq_tmp$x##4870][lq_tmp$x##4826:=w##a1qo][lq_tmp$x##4827:=lq_tmp$x##4870][lq_tmp$x##4828:=lq_anf$##7205759403792801174##d1Ya][lq_tmp$x##4829:=w##a1qo][lq_tmp$x##4839:=w##a1qo]}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4929 : [({lq_tmp$x##4918 : GHC.Types.Int | 0 &lt; lq_tmp$x##4918}, {lq_tmp$x##4919 : GHC.Types.Int | 0 &lt; lq_tmp$x##4919})] | Example.notEmpty lq_tmp$x##4929
                                                                                                                                     &amp;&amp; lq_tmp$x##4929 == wxs##a1qi
                                                                                                                                     &amp;&amp; len lq_tmp$x##4929 &gt;= 0}</span><span class='hs-varid'>wxs</span></a>
<span class=hs-linenum>322: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp$x##4738 : [{lq_tmp$x##4763 : GHC.Types.Int | $k_##4762[VV##4761:=lq_tmp$x##4763][lq_tmp$x##4743:=lq_anf$##7205759403792801173##d1Y9][lq_tmp$x##4744:=wxs##a1qi]}] | Example.notEmpty wxs##a1qi &lt;=&gt; Example.notEmpty lq_tmp$x##4738}</span><span class='hs-varid'>weights</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>ds_d1UA:{VV##4683 : ({VV##4676 : GHC.Types.Int | $k_##4677}, {VV##4678 : GHC.Types.Int | $k_##4679})&lt;\lq_tmp$x##4680 VV -&gt; {VV##4681 : GHC.Types.Int | $k_##4682}&gt; | $k_##4684} -&gt; {VV##4686 : GHC.Types.Int | $k_##4687}</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4692 : ({lq_tmp$x##4688 : GHC.Types.Int | $k_##4677[VV##4676:=lq_tmp$x##4688][VV##4683:=lq_tmp$x##4692]}, {lq_tmp$x##4689 : GHC.Types.Int | $k_##4679[VV##4678:=lq_tmp$x##4689][VV##4683:=lq_tmp$x##4692]})&lt;\lq_tmp$x##4693 VV -&gt; {lq_tmp$x##4691 : GHC.Types.Int | $k_##4682[VV##4681:=lq_tmp$x##4691][VV##4683:=lq_tmp$x##4692][lq_tmp$x##4680:=lq_tmp$x##4693][lq_tmp$x##4690:=lq_tmp$x##4693]}&gt; | lq_tmp$x##4692 == ds_d1UA
                                                                                                                                                                                                                                                                                                                                                                                                                 &amp;&amp; $k_##4684[VV##4683:=lq_tmp$x##4692]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4726 : GHC.Types.Int | lq_tmp$x##4726 == w##a1qq
                                  &amp;&amp; $k_##4677[VV##4676:=lq_tmp$x##4726][VV##4683:=lq_anf$##7205759403792801172##d1Y8][lq_tmp$x##4688:=lq_tmp$x##4726][lq_tmp$x##4692:=lq_anf$##7205759403792801172##d1Y8][lq_tmp$x##4695:=lq_tmp$x##4726][lq_tmp$x##4699:=lq_anf$##7205759403792801172##d1Y8]}</span><span class='hs-varid'>w</span></a>    <span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4785 : [({lq_tmp$x##4774 : GHC.Types.Int | 0 &lt; lq_tmp$x##4774}, {lq_tmp$x##4775 : GHC.Types.Int | 0 &lt; lq_tmp$x##4775})] | Example.notEmpty lq_tmp$x##4785
                                                                                                                                     &amp;&amp; lq_tmp$x##4785 == wxs##a1qi
                                                                                                                                     &amp;&amp; len lq_tmp$x##4785 &gt;= 0}</span><span class='hs-varid'>wxs</span></a>
<span class=hs-linenum>323: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp$x##4938 : GHC.Types.Int | $k_##4666[VV##4665:=lq_tmp$x##4938][lq_tmp$x##4662:=lq_anf$##7205759403792801171##d1Y7][lq_tmp$x##4663:=elems##a1qj][lq_tmp$x##4667:=lq_tmp$x##4938][lq_tmp$x##4941:=elems##a1qj]}</span><span class='hs-varid'>totElems</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4938 : GHC.Types.Int | $k_##4666[VV##4665:=lq_tmp$x##4938][lq_tmp$x##4662:=lq_anf$##7205759403792801171##d1Y7][lq_tmp$x##4663:=elems##a1qj][lq_tmp$x##4667:=lq_tmp$x##4938][lq_tmp$x##4941:=elems##a1qj]}</span><span class='hs-varid'>sum</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4946 : [{lq_tmp$x##4943 : GHC.Types.Int | $k_##4906[VV##4905:=lq_tmp$x##4943][lq_tmp$x##4882:=lq_tmp$x##4946][lq_tmp$x##4887:=lq_anf$##7205759403792801175##d1Yb][lq_tmp$x##4888:=wxs##a1qi][lq_tmp$x##4907:=lq_tmp$x##4943]}] | (Example.notEmpty wxs##a1qi &lt;=&gt; Example.notEmpty lq_tmp$x##4946)
                                                                                                                                                                                                                                            &amp;&amp; lq_tmp$x##4946 == elems##a1qj
                                                                                                                                                                                                                                            &amp;&amp; len lq_tmp$x##4946 &gt;= 0}</span><span class='hs-varid'>elems</span></a>
<span class=hs-linenum>324: </span>    <a class=annot href="#"><span class=annottext>{lq_tmp$x##4794 : GHC.Types.Int | $k_##4666[VV##4665:=lq_tmp$x##4794][lq_tmp$x##4662:=lq_anf$##7205759403792801171##d1Y7][lq_tmp$x##4663:=weights##a1qk][lq_tmp$x##4667:=lq_tmp$x##4794][lq_tmp$x##4797:=weights##a1qk]}</span><span class='hs-varid'>totWeight</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4794 : GHC.Types.Int | $k_##4666[VV##4665:=lq_tmp$x##4794][lq_tmp$x##4662:=lq_anf$##7205759403792801171##d1Y7][lq_tmp$x##4663:=weights##a1qk][lq_tmp$x##4667:=lq_tmp$x##4794][lq_tmp$x##4797:=weights##a1qk]}</span><span class='hs-varid'>sum</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4802 : [{lq_tmp$x##4799 : GHC.Types.Int | $k_##4762[VV##4761:=lq_tmp$x##4799][lq_tmp$x##4738:=lq_tmp$x##4802][lq_tmp$x##4743:=lq_anf$##7205759403792801173##d1Y9][lq_tmp$x##4744:=wxs##a1qi][lq_tmp$x##4763:=lq_tmp$x##4799]}] | (Example.notEmpty wxs##a1qi &lt;=&gt; Example.notEmpty lq_tmp$x##4802)
                                                                                                                                                                                                                                            &amp;&amp; lq_tmp$x##4802 == weights##a1qk
                                                                                                                                                                                                                                            &amp;&amp; len lq_tmp$x##4802 &gt;= 0}</span><span class='hs-varid'>weights</span></a>
<span class=hs-linenum>325: </span>    <a class=annot href="#"><span class=annottext>lq_tmp$x##4663:{lq_tmp$x##4655 : [{lq_tmp$x##4667 : GHC.Types.Int | $k_##4666[VV##4665:=lq_tmp$x##4667][lq_tmp$x##4662:=lq_anf$##7205759403792801171##d1Y7]}] | Example.notEmpty lq_tmp$x##4655} -&gt; {lq_tmp$x##4667 : GHC.Types.Int | $k_##4666[VV##4665:=lq_tmp$x##4667][lq_tmp$x##4662:=lq_anf$##7205759403792801171##d1Y7]}</span><span class='hs-varid'>sum</span></a>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##4663:{lq_tmp$x##4655 : [{lq_tmp$x##4667 : GHC.Types.Int | $k_##4666[VV##4665:=lq_tmp$x##4667][lq_tmp$x##4662:=lq_anf$##7205759403792801171##d1Y7]}] | Example.notEmpty lq_tmp$x##4655} -&gt; {lq_tmp$x##4667 : GHC.Types.Int | $k_##4666[VV##4665:=lq_tmp$x##4667][lq_tmp$x##4662:=lq_anf$##7205759403792801171##d1Y7]}</span><span class='hs-varid'>foldl1</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##4641:GHC.Types.Int -&gt; lq_tmp$x##4642:GHC.Types.Int -&gt; {lq_tmp$x##4643 : GHC.Types.Int | lq_tmp$x##4643 == lq_tmp$x##4641 + lq_tmp$x##4642}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>+</span><span class='hs-layout'>)</span>
<span class=hs-linenum>326: </span>
<span class=hs-linenum>327: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>map</span>           <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ys:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| notEmpty xs &lt;=&gt; notEmpty ys}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>328: </span><a class=annot href="#"><span class=annottext>forall t a .
lq_tmp$x##4287:(lq_tmp$x##4285:t -&gt; a) -&gt; lq_tmp$x##4288:[t] -&gt; {ys : [a] | Example.notEmpty lq_tmp$x##4288 &lt;=&gt; Example.notEmpty ys}</span><span class='hs-definition'>map</span></a> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>      <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {lq_tmp$x##4319 : [a]&lt;\lq_tmp$x##4320 VV -&gt; {lq_tmp$x##4318 : a&lt;p lq_tmp$x##4320&gt; | true}&gt; | not (Example.notEmpty lq_tmp$x##4319)
                                                                                                   &amp;&amp; len lq_tmp$x##4319 == 0} | VV == GHC.Types.[]}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>329: </span><span class='hs-definition'>map</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4368 : t | lq_tmp$x##4368 == x##a1qs}</span><span class='hs-varid'>x</span></a> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4380 : [{lq_tmp$x##4394 : a | $k_##4393[VV##4392:=lq_tmp$x##4394][lq_tmp$x##4385:=ds_d1Rh][lq_tmp$x##4386:=xs##a1qt]}] | Example.notEmpty xs##a1qt &lt;=&gt; Example.notEmpty lq_tmp$x##4380}</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##4398:t -&gt; a</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4402 : [t] | lq_tmp$x##4402 == xs##a1qt
                        &amp;&amp; len lq_tmp$x##4402 &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\hint On what variables are the errors? How are those variables' values computed?
Can you think of a better specification for the function(s) doing those computations?

<div class="hwex" id="Mitchell's Risers">
Non-empty lists pop up in many places, and it is rather convenient
to have the type system track non-emptiness without having to make
up special types. Consider the `risers` function, popularized
by [Neil Mitchell][mitchell-riser]. `safeSplit` requires
its input be non-empty; but LiquidHaskell believes that the
call inside `risers` fails this requirement. Fix the
specification for `risers` so that it is verified.
</div>

\begin{code}
<pre><span class=hs-linenum>346: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>risers</span>       <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| notEmpty xs ==&gt; notEmpty v}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>347: </span><span class='hs-definition'>risers</span>           <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>348: </span><a class=annot href="#"><span class=annottext>forall a .
(Ord&lt;[]&gt; a) =&gt;
lq_tmp$x##1435:[a] -&gt; {v : [[a]] | Example.notEmpty lq_tmp$x##1435 =&gt; Example.notEmpty v}</span><span class='hs-definition'>risers</span></a> <span class='hs-conid'>[]</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {lq_tmp$x##1468 : [a]&lt;\lq_tmp$x##1469 VV -&gt; {lq_tmp$x##1467 : a&lt;p lq_tmp$x##1469&gt; | true}&gt; | not (Example.notEmpty lq_tmp$x##1468)
                                                                                                   &amp;&amp; len lq_tmp$x##1468 == 0} | VV == GHC.Types.[]}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>349: </span><span class='hs-definition'>risers</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1594 : [{lq_tmp$x##1606 : [{lq_tmp$x##1603 : a | $k_##1597[VV##1596:=lq_tmp$x##1603][VV##1601:=lq_tmp$x##1606]}]&lt;\lq_tmp$x##1604 VV -&gt; {lq_tmp$x##1605 : a | $k_##1600[VV##1599:=lq_tmp$x##1605][VV##1601:=lq_tmp$x##1606][lq_tmp$x##1598:=lq_tmp$x##1604]}&gt; | $k_##1602[VV##1601:=lq_tmp$x##1606]}]&lt;\lq_tmp$x##1595 VV -&gt; {lq_tmp$x##1606 : [{lq_tmp$x##1603 : a | $k_##1608[VV##1607:=lq_tmp$x##1603][VV##1610:=lq_tmp$x##1605][VV##1612:=lq_tmp$x##1606][lq_tmp$x##1614:=lq_tmp$x##1595]}]&lt;\lq_tmp$x##1604 VV -&gt; {lq_tmp$x##1605 : a | $k_##1611[VV##1607:=lq_tmp$x##1603][VV##1610:=lq_tmp$x##1605][VV##1612:=lq_tmp$x##1606][lq_tmp$x##1614:=lq_tmp$x##1595]}&gt; | $k_##1613[VV##1612:=lq_tmp$x##1606][lq_tmp$x##1614:=lq_tmp$x##1595]}&gt; | not (Example.notEmpty lq_tmp$x##1594)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         &amp;&amp; len lq_tmp$x##1594 == 0}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##1569 : [{lq_tmp$x##1579 : a | $k_##1578[VV##1577:=lq_tmp$x##1579][lq_tmp$x##1573:=x##a1qu][lq_tmp$x##1574:=lq_anf$##7205759403792801099##d1WX]}]&lt;\lq_tmp$x##1576 VV -&gt; {lq_tmp$x##1579 : a | $k_##1581[VV##1580:=lq_tmp$x##1579][lq_tmp$x##1573:=x##a1qu][lq_tmp$x##1574:=lq_anf$##7205759403792801099##d1WX][lq_tmp$x##1582:=lq_tmp$x##1576]}&gt; | Example.notEmpty lq_tmp$x##1569
                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; head lq_tmp$x##1569 == x##a1qu
                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; len lq_tmp$x##1569 == 1 + len lq_anf$##7205759403792801099##d1WX
                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; tail lq_tmp$x##1569 == lq_anf$##7205759403792801099##d1WX}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##1584 : a | lq_tmp$x##1584 == x##a1qu}</span><span class='hs-varid'>x</span></a><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>350: </span><span class='hs-definition'>risers</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-varid'>etc</span><span class='hs-layout'>)</span>
<span class=hs-linenum>351: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2161 : a | lq_tmp$x##2161 == x##a1qu}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2162 : a | lq_tmp$x##2162 == y##a1qw}</span><span class='hs-varid'>y</span></a>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2336 : [{lq_tmp$x##2346 : a | $k_##2345[VV##2344:=lq_tmp$x##2346][lq_tmp$x##2340:=x##a1qu][lq_tmp$x##2341:=s##a1Lx]}]&lt;\lq_tmp$x##2343 VV -&gt; {lq_tmp$x##2346 : a | $k_##2348[VV##2347:=lq_tmp$x##2346][lq_tmp$x##2340:=x##a1qu][lq_tmp$x##2341:=s##a1Lx][lq_tmp$x##2349:=lq_tmp$x##2343]}&gt; | Example.notEmpty lq_tmp$x##2336
                                                                                                                                                                                                                                                                                                       &amp;&amp; head lq_tmp$x##2336 == x##a1qu
                                                                                                                                                                                                                                                                                                       &amp;&amp; len lq_tmp$x##2336 == 1 + len s##a1Lx
                                                                                                                                                                                                                                                                                                       &amp;&amp; tail lq_tmp$x##2336 == s##a1Lx}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##2351 : a | lq_tmp$x##2351 == x##a1qu}</span><span class='hs-varid'>x</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{lq_tmp$x##2355 : [{lq_tmp$x##2352 : a | $k_##1984[VV##1983:=lq_tmp$x##2352][VV##1988:=lq_tmp$x##2355]}]&lt;\lq_tmp$x##2356 VV -&gt; {lq_tmp$x##2354 : a | $k_##1987[VV##1986:=lq_tmp$x##2354][VV##1988:=lq_tmp$x##2355][lq_tmp$x##1985:=lq_tmp$x##2356][lq_tmp$x##2353:=lq_tmp$x##2356]}&gt; | lq_tmp$x##2355 == s##a1Lx
                                                                                                                                                                                                                                                                                       &amp;&amp; len lq_tmp$x##2355 &gt;= 0
                                                                                                                                                                                                                                                                                       &amp;&amp; $k_##1989[VV##1988:=lq_tmp$x##2355]}</span><span class='hs-varid'>s</span></a><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2408 : [{lq_tmp$x##2402 : [{lq_tmp$x##2399 : a | $k_##2056[VV##2055:=lq_tmp$x##2399][VV##2060:=lq_tmp$x##2402][VV##2070:=lq_tmp$x##2408]}]&lt;\lq_tmp$x##2409 VV -&gt; {lq_tmp$x##2401 : a | $k_##2059[VV##2058:=lq_tmp$x##2401][VV##2060:=lq_tmp$x##2402][VV##2070:=lq_tmp$x##2408][lq_tmp$x##2057:=lq_tmp$x##2409][lq_tmp$x##2400:=lq_tmp$x##2409]}&gt; | $k_##2061[VV##2060:=lq_tmp$x##2402][VV##2070:=lq_tmp$x##2408]}]&lt;\lq_tmp$x##2411 VV -&gt; {lq_tmp$x##2407 : [{lq_tmp$x##2404 : a | $k_##2064[VV##2063:=lq_tmp$x##2404][VV##2068:=lq_tmp$x##2407][VV##2070:=lq_tmp$x##2408][lq_tmp$x##2062:=lq_tmp$x##2411][lq_tmp$x##2403:=lq_tmp$x##2411]}]&lt;\lq_tmp$x##2410 VV -&gt; {lq_tmp$x##2406 : a | $k_##2067[VV##2066:=lq_tmp$x##2406][VV##2068:=lq_tmp$x##2407][VV##2070:=lq_tmp$x##2408][lq_tmp$x##2062:=lq_tmp$x##2411][lq_tmp$x##2065:=lq_tmp$x##2410][lq_tmp$x##2403:=lq_tmp$x##2411][lq_tmp$x##2405:=lq_tmp$x##2410]}&gt; | $k_##2069[VV##2068:=lq_tmp$x##2407][VV##2070:=lq_tmp$x##2408][lq_tmp$x##2062:=lq_tmp$x##2411][lq_tmp$x##2403:=lq_tmp$x##2411]}&gt; | lq_tmp$x##2408 == ss##a1Lz
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 &amp;&amp; len lq_tmp$x##2408 &gt;= 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 &amp;&amp; $k_##2071[VV##2070:=lq_tmp$x##2408]}</span><span class='hs-varid'>ss</span></a>
<span class=hs-linenum>352: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2192 : [{lq_tmp$x##2202 : a | $k_##2201[VV##2200:=lq_tmp$x##2202][lq_tmp$x##2196:=x##a1qu][lq_tmp$x##2197:=lq_anf$##7205759403792801107##d1X5]}]&lt;\lq_tmp$x##2199 VV -&gt; {lq_tmp$x##2202 : a | $k_##2204[VV##2203:=lq_tmp$x##2202][lq_tmp$x##2196:=x##a1qu][lq_tmp$x##2197:=lq_anf$##7205759403792801107##d1X5][lq_tmp$x##2205:=lq_tmp$x##2199]}&gt; | Example.notEmpty lq_tmp$x##2192
                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; head lq_tmp$x##2192 == x##a1qu
                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; len lq_tmp$x##2192 == 1 + len lq_anf$##7205759403792801107##d1X5
                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; tail lq_tmp$x##2192 == lq_anf$##7205759403792801107##d1X5}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##2207 : a | lq_tmp$x##2207 == x##a1qu}</span><span class='hs-varid'>x</span></a><span class='hs-keyglyph'>]</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2222 : [{lq_tmp$x##2240 : [{lq_tmp$x##2237 : a | $k_##2231[VV##2230:=lq_tmp$x##2237][VV##2235:=lq_tmp$x##2240][lq_tmp$x##2226:=s##a1Lx][lq_tmp$x##2227:=ss##a1Lz]}]&lt;\lq_tmp$x##2238 VV -&gt; {lq_tmp$x##2239 : a | $k_##2234[VV##2233:=lq_tmp$x##2239][VV##2235:=lq_tmp$x##2240][lq_tmp$x##2226:=s##a1Lx][lq_tmp$x##2227:=ss##a1Lz][lq_tmp$x##2232:=lq_tmp$x##2238]}&gt; | $k_##2236[VV##2235:=lq_tmp$x##2240][lq_tmp$x##2226:=s##a1Lx][lq_tmp$x##2227:=ss##a1Lz]}]&lt;\lq_tmp$x##2229 VV -&gt; {lq_tmp$x##2240 : [{lq_tmp$x##2237 : a | $k_##2242[VV##2241:=lq_tmp$x##2237][VV##2244:=lq_tmp$x##2239][VV##2246:=lq_tmp$x##2240][lq_tmp$x##2226:=s##a1Lx][lq_tmp$x##2227:=ss##a1Lz][lq_tmp$x##2248:=lq_tmp$x##2229]}]&lt;\lq_tmp$x##2238 VV -&gt; {lq_tmp$x##2239 : a | $k_##2245[VV##2241:=lq_tmp$x##2237][VV##2244:=lq_tmp$x##2239][VV##2246:=lq_tmp$x##2240][lq_tmp$x##2226:=s##a1Lx][lq_tmp$x##2227:=ss##a1Lz][lq_tmp$x##2248:=lq_tmp$x##2229]}&gt; | $k_##2247[VV##2246:=lq_tmp$x##2240][lq_tmp$x##2226:=s##a1Lx][lq_tmp$x##2227:=ss##a1Lz][lq_tmp$x##2248:=lq_tmp$x##2229]}&gt; | Example.notEmpty lq_tmp$x##2222
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; head lq_tmp$x##2222 == s##a1Lx
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; len lq_tmp$x##2222 == 1 + len ss##a1Lz
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; tail lq_tmp$x##2222 == ss##a1Lz}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##2253 : [{lq_tmp$x##2250 : a | $k_##1984[VV##1983:=lq_tmp$x##2250][VV##1988:=lq_tmp$x##2253]}]&lt;\lq_tmp$x##2254 VV -&gt; {lq_tmp$x##2252 : a | $k_##1987[VV##1986:=lq_tmp$x##2252][VV##1988:=lq_tmp$x##2253][lq_tmp$x##1985:=lq_tmp$x##2254][lq_tmp$x##2251:=lq_tmp$x##2254]}&gt; | lq_tmp$x##2253 == s##a1Lx
                                                                                                                                                                                                                                                                                       &amp;&amp; len lq_tmp$x##2253 &gt;= 0
                                                                                                                                                                                                                                                                                       &amp;&amp; $k_##1989[VV##1988:=lq_tmp$x##2253]}</span><span class='hs-varid'>s</span></a> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2264 : [{lq_tmp$x##2258 : [{lq_tmp$x##2255 : a | $k_##2056[VV##2055:=lq_tmp$x##2255][VV##2060:=lq_tmp$x##2258][VV##2070:=lq_tmp$x##2264]}]&lt;\lq_tmp$x##2265 VV -&gt; {lq_tmp$x##2257 : a | $k_##2059[VV##2058:=lq_tmp$x##2257][VV##2060:=lq_tmp$x##2258][VV##2070:=lq_tmp$x##2264][lq_tmp$x##2057:=lq_tmp$x##2265][lq_tmp$x##2256:=lq_tmp$x##2265]}&gt; | $k_##2061[VV##2060:=lq_tmp$x##2258][VV##2070:=lq_tmp$x##2264]}]&lt;\lq_tmp$x##2267 VV -&gt; {lq_tmp$x##2263 : [{lq_tmp$x##2260 : a | $k_##2064[VV##2063:=lq_tmp$x##2260][VV##2068:=lq_tmp$x##2263][VV##2070:=lq_tmp$x##2264][lq_tmp$x##2062:=lq_tmp$x##2267][lq_tmp$x##2259:=lq_tmp$x##2267]}]&lt;\lq_tmp$x##2266 VV -&gt; {lq_tmp$x##2262 : a | $k_##2067[VV##2066:=lq_tmp$x##2262][VV##2068:=lq_tmp$x##2263][VV##2070:=lq_tmp$x##2264][lq_tmp$x##2062:=lq_tmp$x##2267][lq_tmp$x##2065:=lq_tmp$x##2266][lq_tmp$x##2259:=lq_tmp$x##2267][lq_tmp$x##2261:=lq_tmp$x##2266]}&gt; | $k_##2069[VV##2068:=lq_tmp$x##2263][VV##2070:=lq_tmp$x##2264][lq_tmp$x##2062:=lq_tmp$x##2267][lq_tmp$x##2259:=lq_tmp$x##2267]}&gt; | lq_tmp$x##2264 == ss##a1Lz
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 &amp;&amp; len lq_tmp$x##2264 &gt;= 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 &amp;&amp; $k_##2071[VV##2070:=lq_tmp$x##2264]}</span><span class='hs-varid'>ss</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>353: </span>    <span class='hs-keyword'>where</span>
<span class=hs-linenum>354: </span>      <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV##1988 : [{VV##1983 : a | $k_##1984}]&lt;\lq_tmp$x##1985 VV -&gt; {VV##1986 : a | $k_##1987}&gt; | $k_##1989}</span><span class='hs-varid'>s</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV##2070 : [{VV##2060 : [{VV##2055 : a | $k_##2056}]&lt;\lq_tmp$x##2057 VV -&gt; {VV##2058 : a | $k_##2059}&gt; | $k_##2061}]&lt;\lq_tmp$x##2062 VV -&gt; {VV##2068 : [{VV##2063 : a | $k_##2064}]&lt;\lq_tmp$x##2065 VV -&gt; {VV##2066 : a | $k_##2067}&gt; | $k_##2069}&gt; | $k_##2071}</span><span class='hs-varid'>ss</span></a><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##1724:{lq_tmp$x##1710 : [a] | Example.notEmpty lq_tmp$x##1710} -&gt; (a, [a]) | VV == Example.safeSplit}</span><span class='hs-varid'>safeSplit</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1786 : [[{lq_tmp$x##1798 : a | $k_##1797[VV##1796:=lq_tmp$x##1798][lq_tmp$x##1790:=fix$36$$36$dOrd_a1Lp][lq_tmp$x##1791:=lq_anf$##7205759403792801103##d1X1]}]] | Example.notEmpty lq_anf$##7205759403792801103##d1X1 =&gt; Example.notEmpty lq_tmp$x##1786}</span><span class='hs-varid'>risers</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1749 : [{lq_tmp$x##1759 : a | $k_##1758[VV##1757:=lq_tmp$x##1759][lq_tmp$x##1753:=y##a1qw][lq_tmp$x##1754:=etc##a1qx]}]&lt;\lq_tmp$x##1756 VV -&gt; {lq_tmp$x##1759 : a | $k_##1761[VV##1760:=lq_tmp$x##1759][lq_tmp$x##1753:=y##a1qw][lq_tmp$x##1754:=etc##a1qx][lq_tmp$x##1762:=lq_tmp$x##1756]}&gt; | Example.notEmpty lq_tmp$x##1749
                                                                                                                                                                                                                                                                                                           &amp;&amp; head lq_tmp$x##1749 == y##a1qw
                                                                                                                                                                                                                                                                                                           &amp;&amp; len lq_tmp$x##1749 == 1 + len etc##a1qx
                                                                                                                                                                                                                                                                                                           &amp;&amp; tail lq_tmp$x##1749 == etc##a1qx}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##1764 : a | lq_tmp$x##1764 == y##a1qw}</span><span class='hs-varid'>y</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{lq_tmp$x##1768 : [a] | lq_tmp$x##1768 == etc##a1qx
                        &amp;&amp; len lq_tmp$x##1768 &gt;= 0}</span><span class='hs-varid'>etc</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>355: </span>
<span class=hs-linenum>356: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>safeSplit</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>357: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1271:{VV##0 : [a] | Example.notEmpty VV##0} -&gt; (a, [a])</span><span class='hs-definition'>safeSplit</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a b &lt;p2 :: a b -&gt; Bool&gt;.
      lq_tmp$x##1400:a -&gt; lq_tmp$x##1401:{lq_tmp$x##1392 : b&lt;p2 lq_tmp$x##1400&gt; | true} -&gt; {lq_tmp$x##1397 : (a, b)&lt;\lq_tmp$x##1402 VV -&gt; {lq_tmp$x##1396 : b&lt;p2 lq_tmp$x##1402&gt; | true}&gt; | fst lq_tmp$x##1397 == lq_tmp$x##1400
                                                                                                                                                                                            &amp;&amp; snd lq_tmp$x##1397 == lq_tmp$x##1401
                                                                                                                                                                                            &amp;&amp; x_Tuple21 lq_tmp$x##1397 == lq_tmp$x##1400
                                                                                                                                                                                            &amp;&amp; x_Tuple22 lq_tmp$x##1397 == lq_tmp$x##1401} | VV == GHC.Tuple.(,)}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##1426 : a | lq_tmp$x##1426 == x##a1qA}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1430 : [a] | lq_tmp$x##1430 == xs##a1qB
                        &amp;&amp; len lq_tmp$x##1430 &gt;= 0}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>358: </span><span class='hs-definition'>safeSplit</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##1318:{lq_tmp$x##1314 : [GHC.Types.Char] | false} -&gt; a | VV == Example.die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1305 : [GHC.Types.Char] | len lq_tmp$x##1305 == strLen lq_anf$##7205759403792801095##d1WT
                                     &amp;&amp; lq_tmp$x##1305 ~~ lq_anf$##7205759403792801095##d1WT}</span><span class='hs-str'>"don't worry, be happy"</span></a>
</pre>\end{code}



Recap
-----

In this chapter we saw how LiquidHaskell lets you

1. *Define* structural properties of data types,

2. *Use refinements* over these properties to describe key
   invariants that establish, at compile-time, the safety
   of operations that might otherwise fail on unexpected
   values at run-time, all while,

3. *Working with plain Haskell types*, here, Lists,
   without having to [make up new types][apple-riser]
   which can have the unfortunate effect of adding
   a multitude of constructors and conversions which
   often clutter implementations and specifications.

\noindent
Of course, we can do a lot more with measures, so lets press on!




</body>
</html>