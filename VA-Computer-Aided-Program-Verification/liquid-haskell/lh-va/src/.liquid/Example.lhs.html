<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>/home/ricardo/docencia/verifAsistid/2021-22/versionProfesor/LiquidHaskell/lh-tests/src/Example.lhs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types

Boolean Measures {#boolmeasures}
================


In the last two chapters, we saw how refinements could be used to
reason about the properties of basic `Int` values like vector
indices, or the elements of a list. Next, lets see how we can
describe properties of aggregate structures like lists and trees,
and use these properties to improve the APIs for operating over
such structures.

\begin{comment}
\begin{code}
<pre><span class=hs-linenum>15: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>16: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--short-names"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>17: </span>
<span class=hs-linenum>18: </span>
<span class=hs-linenum>19: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Example</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>20: </span>
<span class=hs-linenum>21: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span><span class='hs-layout'>(</span><span class='hs-varid'>foldl</span><span class='hs-layout'>,</span> <span class='hs-varid'>foldl1</span><span class='hs-layout'>,</span> <span class='hs-varid'>map</span><span class='hs-layout'>,</span> <span class='hs-varid'>sum</span><span class='hs-layout'>,</span> <span class='hs-varid'>head</span><span class='hs-layout'>,</span> <span class='hs-varid'>tail</span><span class='hs-layout'>,</span> <span class='hs-varid'>null</span><span class='hs-layout'>)</span>
<span class=hs-linenum>22: </span>
<span class=hs-linenum>23: </span><a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-definition'>main</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>putStrLn</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Hello"</span></a>
<span class=hs-linenum>24: </span>
<span class=hs-linenum>25: </span><span class='hs-comment'>-- | Old Definitions</span>
<span class=hs-linenum>26: </span>
<span class=hs-linenum>27: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Nat</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>0</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>28: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Pos</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>0</span> <span class='hs-varop'>&lt;</span>  <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>29: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>NonZero</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>0</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>30: </span>
<span class=hs-linenum>31: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>die</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{v:</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>| false}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>32: </span><a class=annot href="#"><span class=annottext>forall a . {v : [GHC.Types.Char] | false} -&gt; a</span><span class='hs-definition'>die</span></a> <a class=annot href="#"><span class=annottext>{VV : [GHC.Types.Char] | false}</span><span class='hs-varid'>msg</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | false}</span><span class='hs-varid'>msg</span></a>
<span class=hs-linenum>33: </span>
<span class=hs-linenum>34: </span><span class='hs-comment'>-- Type Definitions</span>
<span class=hs-linenum>35: </span><span class='hs-definition'>divide</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>36: </span><span class='hs-definition'>size1</span><span class='hs-layout'>,</span> <span class='hs-varid'>size2</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
</pre>\end{code}
\end{comment}


Partial Functions
------------------

As a motivating example, let us return to the problem of ensuring
the safety of division. Recall that we wrote:

\begin{code}
<pre><span class=hs-linenum>48: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>divide</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NonZero</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>49: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; {VV : GHC.Types.Int | 0 /= VV} -&gt; GHC.Types.Int</span><span class='hs-definition'>divide</span></a> <span class='hs-keyword'>_</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a . {v : [GHC.Types.Char] | false} -&gt; a | VV == die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"divide-by-zero"</span></a>
<span class=hs-linenum>50: </span><span class='hs-definition'>divide</span> <span class='hs-varid'>x</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>`div`</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | 0 /= v}</span><span class='hs-varid'>n</span></a>
</pre>\end{code}

\newthought{The Precondition} asserted by the input type `NonZero`
allows LiquidHaskell to prove that the `die` is *never* executed at
run-time, but consequently, requires us to establish that wherever
`divide` is *used*, the second parameter be provably non-zero.
This requirement is not onerous when we know what the
divisor is *statically*

\begin{code}
<pre><span class=hs-linenum>61: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-definition'>avg2</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>divide</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x + y}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == y}</span><span class='hs-varid'>y</span></a><span class='hs-layout'>)</span>     <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a>
<span class=hs-linenum>62: </span>
<span class=hs-linenum>63: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-definition'>avg3</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>z</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>divide</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == y}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == z}</span><span class='hs-varid'>z</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>3</span></a>
</pre>\end{code}

\noindent However, it can be more of a challenge when the divisor
is obtained *dynamically*. For example, lets write a function to
find the number of elements in a list

\begin{code}
<pre><span class=hs-linenum>71: </span><span class='hs-definition'>size</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>72: </span><a class=annot href="#"><span class=annottext>forall a .
x1:[a] -&gt; {VV : GHC.Types.Int | (notEmpty x1 =&gt; VV &gt; 0)
                                &amp;&amp; VV &gt;= 0}</span><span class='hs-definition'>size</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == 0}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>73: </span><span class='hs-definition'>size</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty xs =&gt; v &gt; 0)
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\noindent and use it to compute the average value of a list:

\begin{code}
<pre><span class=hs-linenum>79: </span><a class=annot href="#"><span class=annottext>[GHC.Types.Int] -&gt; GHC.Types.Int</span><span class='hs-definition'>avgMany</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Int]</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; {v : GHC.Types.Int | 0 /= v} -&gt; GHC.Types.Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == total}</span><span class='hs-varid'>total</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty xs =&gt; v &gt; 0)
                     &amp;&amp; v == elems
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a></span>
<span class=hs-linenum>80: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>81: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>total</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>sum</span></a>  <span class=hs-error><a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | v == xs
                       &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a></span>
<span class=hs-linenum>82: </span>    <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty xs =&gt; v &gt; 0)
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
x1:[a] -&gt; {VV : GHC.Types.Int | (notEmpty x1 =&gt; VV &gt; 0)
                                &amp;&amp; VV &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | v == xs
                       &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

Uh oh. LiquidHaskell wags its finger at us!

~~~~~{.liquiderror}
     src/04-measure.lhs:77:27-31: Error: Liquid Type Mismatch
       Inferred type
         VV : Int | VV == elems

       not a subtype of Required type
         VV : Int | 0 /= VV

       In Context
         VV    : Int | VV == elems
         elems : Int
~~~~~

\newthought{We cannot prove} that the divisor is `NonZero`,
because it *can be* `0` -- when the list is *empty*. Thus, we
need a way of specifying that the input to `avgMany` is indeed
non-empty!

Lifting Functions to Measures {#usingmeasures}
-----------------------------

\newthought{How} shall we tell LiquidHaskell that a list is *non-empty*?
Recall the notion of `measure` previously [introduced](#vectorbounds)
to describe the size of a `Data.Vector`. In that spirit, lets write
a function that computes whether a list is not empty:

\begin{code}
<pre><span class=hs-linenum>114: </span><span class='hs-definition'>notEmpty</span>       <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>115: </span><a class=annot href="#"><span class=annottext>forall a . x1:[a] -&gt; {VV : GHC.Types.Bool | VV &lt;=&gt; notEmpty x1}</span><span class='hs-definition'>notEmpty</span></a> <span class='hs-conid'>[]</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | not v
                      &amp;&amp; v == False}</span><span class='hs-conid'>False</span></a>
<span class=hs-linenum>116: </span><span class='hs-definition'>notEmpty</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v
                      &amp;&amp; v == True}</span><span class='hs-conid'>True</span></a>
</pre>\end{code}

\newthought{A measure} is a *total* Haskell function,

1. With a *single* equation per data constructor, and
2. Guaranteed to *terminate*, typically via structural recursion.

\noindent
We can tell LiquidHaskell to *lift* a function meeting
the above requirements into the refinement logic by declaring:

\begin{code}
<pre><span class=hs-linenum>129: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>notEmpty</span> <span class='hs-keyword'>@-}</span>
</pre>\end{code}


\newthought{Non-Empty Lists} can now be described as
the *subset* of plain old Haskell lists `[a]` for which
the predicate `notEmpty` holds

\begin{code}
<pre><span class=hs-linenum>138: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>notEmpty</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>\end{code}

We can now refine various signatures to establish the safety of
the list-average function.

\newthought{Size} returns a non-zero value *if* the input list is
not-empty. We capture this condition with an [implication](#semantics)
in the output refinement.

\begin{code}
<pre><span class=hs-linenum>149: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| notEmpty xs =&gt; v &gt; 0}</span> <span class='hs-keyword'>@-}</span>
</pre>\end{code}

\newthought{Average} is only sensible for non-empty lists.
Happily, we can specify this using the refined `NEList` type:

\begin{code}
<pre><span class=hs-linenum>156: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>average</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>157: </span><a class=annot href="#"><span class=annottext>{VV : [GHC.Types.Int] | notEmpty VV} -&gt; GHC.Types.Int</span><span class='hs-definition'>average</span></a> <a class=annot href="#"><span class=annottext>{VV : [GHC.Types.Int] | notEmpty VV}</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; {v : GHC.Types.Int | 0 /= v} -&gt; GHC.Types.Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == total}</span><span class='hs-varid'>total</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty xs =&gt; v &gt; 0)
                     &amp;&amp; v == elems
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a>
<span class=hs-linenum>158: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>159: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>total</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>sum</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | notEmpty v
                       &amp;&amp; v == xs
                       &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>160: </span>    <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty xs =&gt; v &gt; 0)
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
x1:[a] -&gt; {VV : GHC.Types.Int | (notEmpty x1 =&gt; VV &gt; 0)
                                &amp;&amp; VV &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | notEmpty v
                       &amp;&amp; v == xs
                       &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

<div class="hwex" id="Average, Maybe">
Fix the code below to obtain an alternate variant
`average'` that returns `Nothing` for empty lists:
</div>

\begin{code}
<pre><span class=hs-linenum>169: </span><span class='hs-definition'>average'</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>170: </span><a class=annot href="#"><span class=annottext>[GHC.Types.Int] -&gt; (GHC.Maybe.Maybe GHC.Types.Int)</span><span class='hs-definition'>average'</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Int]</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>171: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ok</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:a -&gt; {v : (GHC.Maybe.Maybe a) | isJust v
                                         &amp;&amp; fromJust v == x1} | VV == Just}</span><span class='hs-conid'>Just</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>sum</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | v == xs
                       &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty xs =&gt; v &gt; 0)
                     &amp;&amp; v == elems
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a>
<span class=hs-linenum>172: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}</span><span class='hs-conid'>Nothing</span></a>
<span class=hs-linenum>173: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>174: </span>    <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty xs =&gt; v &gt; 0)
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>elems</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
x1:[a] -&gt; {VV : GHC.Types.Int | (notEmpty x1 =&gt; VV &gt; 0)
                                &amp;&amp; VV &gt;= 0}</span><span class='hs-varid'>size</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | v == xs
                       &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>175: </span>    <span class='hs-varid'>ok</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; notEmpty xs}</span><span class='hs-varid'>notEmpty</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | v == xs
                       &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>   <span class='hs-comment'>-- What expression goes here?</span>
</pre>\end{code}

<div class="hwex" id="Debugging Specifications">
An important aspect of formal verifiers like LiquidHaskell
is that they help establish properties not just of your *implementations*
but equally, or more importantly, of your *specifications*. In that spirit,
can you explain why the following two variants of `size` are *rejected*
by LiquidHaskell?
</div>

\begin{code}
<pre><span class=hs-linenum>187: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size1</span>    <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Pos</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>188: </span><a class=annot href="#"><span class=annottext>forall a .
{VV : [a] | notEmpty VV} -&gt; {VV : GHC.Types.Int | 0 &lt; VV}</span><span class='hs-definition'>size1</span></a> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span>    <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == 1}</span><span class='hs-num'>1</span></a>
<span class=hs-linenum>189: </span><span class='hs-definition'>size1</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | 0 &lt; v}</span><span class='hs-varid'>size1</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>190: </span>
<span class=hs-linenum>191: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size2</span>    <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| notEmpty xs =&gt; v &gt; 0}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>192: </span><a class=annot href="#"><span class=annottext>forall a . x1:[a] -&gt; {v : GHC.Types.Int | notEmpty x1 =&gt; v &gt; 0}</span><span class='hs-definition'>size2</span></a> <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == 0}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>193: </span><span class='hs-definition'>size2</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>forall a .
{VV : [a] | notEmpty VV} -&gt; {VV : GHC.Types.Int | 0 &lt; VV}</span><span class='hs-varid'>size1</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}


A Safe List API
---------------

Now that we can talk about non-empty lists, we can ensure
the safety of various list-manipulating functions which
are only well-defined on non-empty lists and crash otherwise.

\newthought{Head and Tail} are two of the canonical *dangerous*
functions, that only work on non-empty lists, and burn horribly
otherwise. We can type them simple as:


\begin{code}
<pre><span class=hs-linenum>210: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>head</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>211: </span><a class=annot href="#"><span class=annottext>forall a . {VV : [a] | notEmpty VV} -&gt; a</span><span class='hs-definition'>head</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>212: </span><span class='hs-definition'>head</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a . {v : [GHC.Types.Char] | false} -&gt; a | VV == die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Fear not! 'twill ne'er come to pass"</span></a>
<span class=hs-linenum>213: </span>
<span class=hs-linenum>214: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>tail</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>215: </span><a class=annot href="#"><span class=annottext>forall a . {VV : [a] | notEmpty VV} -&gt; [a]</span><span class='hs-definition'>tail</span></a> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>216: </span><span class='hs-definition'>tail</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a . {v : [GHC.Types.Char] | false} -&gt; a | VV == die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Relaxeth! this too shall ne'er be"</span></a>
</pre>\end{code}

LiquidHaskell uses the precondition to deduce that
the second equations are *dead code*. Of course, this
requires us to establish that *callers* of `head` and `tail`
only invoke the respective functions with non-empty lists.

<div class="hwex" id="Safe Head">
Write down a specification for `null` such that `safeHead`
is verified. Do *not* force `null` to only take non-empty inputs,
that defeats the purpose. Instead, its type should say that it
works on *all* lists and returns `True` *if and only if* the input
is non-empty.
</div>

\hint You may want to refresh your memory about implies `==>`
and `<=>` from the [chapter on logic](#semantics).

\begin{code}
<pre><span class=hs-linenum>236: </span><span class='hs-definition'>safeHead</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>237: </span><a class=annot href="#"><span class=annottext>forall a . [a] -&gt; (GHC.Maybe.Maybe a)</span><span class='hs-definition'>safeHead</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>238: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; not (notEmpty xs)}</span><span class='hs-varid'>null</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}</span><span class='hs-conid'>Nothing</span></a>
<span class=hs-linenum>239: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:a -&gt; {v : (GHC.Maybe.Maybe a) | isJust v
                                         &amp;&amp; fromJust v == x1} | VV == Just}</span><span class='hs-conid'>Just</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>head</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>240: </span>
<span class=hs-linenum>241: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>null</span>      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{b:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| b &lt;=&gt; not (notEmpty xs)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>242: </span><a class=annot href="#"><span class=annottext>forall a . x1:[a] -&gt; {b : GHC.Types.Bool | b &lt;=&gt; not (notEmpty x1)}</span><span class='hs-definition'>null</span></a> <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v
                      &amp;&amp; v == True}</span><span class='hs-conid'>True</span></a>
<span class=hs-linenum>243: </span><span class='hs-definition'>null</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | not v
                      &amp;&amp; v == False}</span><span class='hs-conid'>False</span></a>
</pre>\end{code}

\newthought{Groups}
Lets use the above to write a function that chunks sequences
into non-empty groups of equal elements:

\begin{code}
<pre><span class=hs-linenum>251: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>groupEq</span>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>252: </span><a class=annot href="#"><span class=annottext>forall a . (Eq&lt;[]&gt; a) =&gt; [a] -&gt; [{VV : [a] | notEmpty VV}]</span><span class='hs-definition'>groupEq</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | not (notEmpty v)
                                                  &amp;&amp; len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>253: </span><span class='hs-definition'>groupEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v
           &amp;&amp; head v == x
           &amp;&amp; len v == 1 + len ys
           &amp;&amp; tail v == ys}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{v : [a] | v == ys
           &amp;&amp; len v &gt;= 0
           &amp;&amp; len v &lt;= len xs}</span><span class='hs-varid'>ys</span></a><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>[{v : [a] | notEmpty v}]</span><span class='hs-varid'>groupEq</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == zs
           &amp;&amp; len v &gt;= 0
           &amp;&amp; len v &lt;= len xs}</span><span class='hs-varid'>zs</span></a>
<span class=hs-linenum>254: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>255: </span>    <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : [a] | len VV &gt;= 0
            &amp;&amp; len VV &lt;= len xs}</span><span class='hs-varid'>ys</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : [a] | len VV &gt;= 0
            &amp;&amp; len VV &lt;= len xs}</span><span class='hs-varid'>zs</span></a><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:a -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x == x1}</span><span class='hs-varid'>span</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>==</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\noindent By using the fact that *each element* in the
output returned by `groupEq` is in fact of the form `x:ys`,
LiquidHaskell infers that `groupEq` returns a `[NEList a]`
that is, a list of *non-empty lists*.

\newthought{To Eliminate Stuttering} from a string, we can use `groupEq`
to split the string into blocks of repeating `Char`s, and then just
extract the first `Char` from each block:

\begin{code}
<pre><span class=hs-linenum>268: </span><span class='hs-comment'>-- &gt;&gt;&gt; eliminateStutter "ssstringssss liiiiiike thisss"</span>
<span class=hs-linenum>269: </span><span class='hs-comment'>-- "strings like this"</span>
<span class=hs-linenum>270: </span><a class=annot href="#"><span class=annottext>forall a . (Eq&lt;[]&gt; a) =&gt; [a] -&gt; [a]</span><span class='hs-definition'>eliminateStutter</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[[a]] -&gt; {v : [a] | notEmpty x1 &lt;=&gt; notEmpty v}</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a . {v : [a] | notEmpty v} -&gt; a | VV == head}</span><span class='hs-varid'>head</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>[{v : [a] | notEmpty v}]</span><span class='hs-varid'>groupEq</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\noindent
LiquidHaskell automatically instantiates the type parameter
for `map` in `eliminateStutter` to `notEmpty v` to deduce that
`head` is only called on non-empty lists.

\newthought{Foldl1} is one of my favorite folds; it uses
the first element of the sequence as the initial value.
Of course, it should only be called with non-empty sequences!

\begin{code}
<pre><span class=hs-linenum>283: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>foldl1</span>         <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>284: </span><a class=annot href="#"><span class=annottext>forall a . (a -&gt; a -&gt; a) -&gt; {VV : [a] | notEmpty VV} -&gt; a</span><span class='hs-definition'>foldl1</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a -&gt; a</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b . (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span><span class='hs-varid'>foldl</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a -&gt; a</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>285: </span><span class='hs-definition'>foldl1</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a . {v : [GHC.Types.Char] | false} -&gt; a | VV == die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"foldl1"</span></a>
<span class=hs-linenum>286: </span>
<span class=hs-linenum>287: </span><span class='hs-definition'>foldl</span>              <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>288: </span><a class=annot href="#"><span class=annottext>forall a b . (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span><span class='hs-definition'>foldl</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>acc</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == acc}</span><span class='hs-varid'>acc</span></a>
<span class=hs-linenum>289: </span><span class='hs-definition'>foldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>acc</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b . (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span><span class='hs-varid'>foldl</span></a> <a class=annot href="#"><span class=annottext>a -&gt; b -&gt; a</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-layout'>(</span></a><span class='hs-varid'>f</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == acc}</span><span class='hs-varid'>acc</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\newthought{To Sum} a non-empty list of numbers, we can just
perform a `foldl1` with the `+` operator:
Thanks to the precondition, LiquidHaskell will prove that
the `die` code is indeed dead. Thus, we can write

\begin{code}
<pre><span class=hs-linenum>298: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>sum</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>299: </span><a class=annot href="#"><span class=annottext>forall a . (Num&lt;[]&gt; a) =&gt; {VV : [a] | notEmpty VV} -&gt; a</span><span class='hs-definition'>sum</span></a> <span class='hs-conid'>[]</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a . {v : [GHC.Types.Char] | false} -&gt; a | VV == die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"cannot add up empty list"</span></a>
<span class=hs-linenum>300: </span><span class='hs-definition'>sum</span> <span class='hs-varid'>xs</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      (a -&gt; a -&gt; a) -&gt; {v : [a] | notEmpty v} -&gt; a | VV == foldl1}</span><span class='hs-varid'>foldl1</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {VV : a | VV == x1 + x2}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\noindent Consequently, we can only invoke `sum` on non-empty lists, so:

\begin{code}
<pre><span class=hs-linenum>306: </span><a class=annot href="#"><span class=annottext>GHC.Integer.Type.Integer</span><span class='hs-definition'>sumOk</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Integer.Type.Integer] | notEmpty v}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Integer.Type.Integer | v == 1}</span><span class='hs-num'>1</span></a><span class='hs-layout'>,</span><a class=annot href="#"><span class=annottext>{v : GHC.Integer.Type.Integer | v == 2}</span><span class='hs-num'>2</span></a><span class='hs-layout'>,</span><a class=annot href="#"><span class=annottext>{v : GHC.Integer.Type.Integer | v == 3}</span><span class='hs-num'>3</span></a><span class='hs-layout'>,</span><a class=annot href="#"><span class=annottext>{v : GHC.Integer.Type.Integer | v == 4}</span><span class='hs-num'>4</span></a><span class='hs-layout'>,</span><a class=annot href="#"><span class=annottext>{v : GHC.Integer.Type.Integer | v == 5}</span><span class='hs-num'>5</span></a><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- is accepted by LH, but</span>
<span class=hs-linenum>307: </span>
<span class=hs-linenum>308: </span><span class=hs-error><a class=annot href="#"><span class=annottext>GHC.Integer.Type.Integer</span><span class='hs-definition'>sumBad</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-keyglyph'>=</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>sum</span></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | not (notEmpty v)
                                                  &amp;&amp; len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a></span>             <span class='hs-comment'>-- is rejected by LH</span>
</pre>\end{code}

<div class="hwex" id="Weighted Average">
The function below computes a weighted average of its input.
Unfortunately, LiquidHaskell is not very happy about it. Can you figure out
why, and fix the code or specification appropriately?
</div>

\begin{code}
<pre><span class=hs-linenum>318: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>wtAverage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pos</span><span class='hs-layout'>,</span> <span class='hs-conid'>Pos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>319: </span><a class=annot href="#"><span class=annottext>{VV : [({VV : GHC.Types.Int | 0 &lt; VV}, {VV : GHC.Types.Int | 0 &lt; VV})] | notEmpty VV} -&gt; GHC.Types.Int</span><span class='hs-definition'>wtAverage</span></a> <a class=annot href="#"><span class=annottext>{VV : [({VV : GHC.Types.Int | 0 &lt; VV}, {VV : GHC.Types.Int | 0 &lt; VV})] | notEmpty VV}</span><span class='hs-varid'>wxs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; {v : GHC.Types.Int | 0 /= v} -&gt; GHC.Types.Int</span><span class='hs-varid'>divide</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                     &amp;&amp; v == totElems
                     &amp;&amp; 0 /= v
                     &amp;&amp; v /= 0
                     &amp;&amp; v &gt; 0
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>totElems</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                     &amp;&amp; v == totWeight
                     &amp;&amp; 0 /= v
                     &amp;&amp; v /= 0
                     &amp;&amp; v &gt; 0
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>totWeight</span></a>
<span class=hs-linenum>320: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>321: </span>    <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | notEmpty wxs &lt;=&gt; notEmpty v}</span><span class='hs-varid'>elems</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Types.Int, GHC.Types.Int) -&gt; GHC.Types.Int</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.Int, GHC.Types.Int)</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == w}</span><span class='hs-varid'>w</span></a> <span class='hs-varop'>*</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [({v : GHC.Types.Int | 0 &lt; v}, {v : GHC.Types.Int | 0 &lt; v})] | notEmpty v
                                                                    &amp;&amp; v == wxs
                                                                    &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>wxs</span></a>
<span class=hs-linenum>322: </span>    <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | notEmpty wxs &lt;=&gt; notEmpty v}</span><span class='hs-varid'>weights</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>({VV : GHC.Types.Int | (notEmpty wxs =&gt; VV &gt; 0)
                       &amp;&amp; 0 /= VV
                       &amp;&amp; VV /= 0
                       &amp;&amp; VV &gt; 0
                       &amp;&amp; VV &gt;= 0
                       &amp;&amp; 0 &lt; VV}, GHC.Types.Int) -&gt; GHC.Types.Int</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>({v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                      &amp;&amp; 0 /= v
                      &amp;&amp; v /= 0
                      &amp;&amp; v &gt; 0
                      &amp;&amp; v &gt;= 0
                      &amp;&amp; 0 &lt; v}, GHC.Types.Int)</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                     &amp;&amp; v == w
                     &amp;&amp; 0 /= v
                     &amp;&amp; v /= 0
                     &amp;&amp; v &gt; 0
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>w</span></a>    <span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [({v : GHC.Types.Int | 0 &lt; v}, {v : GHC.Types.Int | 0 &lt; v})] | notEmpty v
                                                                    &amp;&amp; v == wxs
                                                                    &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>wxs</span></a>
<span class=hs-linenum>323: </span>    <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                     &amp;&amp; 0 /= v
                     &amp;&amp; v /= 0
                     &amp;&amp; v &gt; 0
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>totElems</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                     &amp;&amp; 0 /= v
                     &amp;&amp; v /= 0
                     &amp;&amp; v &gt; 0
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>sum</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | (notEmpty wxs &lt;=&gt; notEmpty v)
                       &amp;&amp; v == elems
                       &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>elems</span></a>
<span class=hs-linenum>324: </span>    <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                     &amp;&amp; 0 /= v
                     &amp;&amp; v /= 0
                     &amp;&amp; v &gt; 0
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>totWeight</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                     &amp;&amp; 0 /= v
                     &amp;&amp; v /= 0
                     &amp;&amp; v &gt; 0
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>sum</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | (notEmpty wxs &lt;=&gt; notEmpty v)
                       &amp;&amp; v == weights
                       &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>weights</span></a>
<span class=hs-linenum>325: </span>    <a class=annot href="#"><span class=annottext>{v : [{v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                           &amp;&amp; 0 /= v
                           &amp;&amp; v /= 0
                           &amp;&amp; v &gt; 0
                           &amp;&amp; v &gt;= 0
                           &amp;&amp; 0 &lt; v}] | notEmpty v} -&gt; {v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                                                                            &amp;&amp; 0 /= v
                                                                            &amp;&amp; v /= 0
                                                                            &amp;&amp; v &gt; 0
                                                                            &amp;&amp; v &gt;= 0
                                                                            &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>sum</span></a>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [{v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                           &amp;&amp; 0 /= v
                           &amp;&amp; v /= 0
                           &amp;&amp; v &gt; 0
                           &amp;&amp; v &gt;= 0
                           &amp;&amp; 0 &lt; v}] | notEmpty v} -&gt; {v : GHC.Types.Int | (notEmpty wxs =&gt; v &gt; 0)
                                                                            &amp;&amp; 0 /= v
                                                                            &amp;&amp; v /= 0
                                                                            &amp;&amp; v &gt; 0
                                                                            &amp;&amp; v &gt;= 0
                                                                            &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>foldl1</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>+</span><span class='hs-layout'>)</span>
<span class=hs-linenum>326: </span>
<span class=hs-linenum>327: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>map</span>           <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ys:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| notEmpty xs &lt;=&gt; notEmpty ys}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>328: </span><a class=annot href="#"><span class=annottext>forall a b .
(a -&gt; b) -&gt; x3:[a] -&gt; {ys : [b] | notEmpty x3 &lt;=&gt; notEmpty ys}</span><span class='hs-definition'>map</span></a> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>      <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | not (notEmpty v)
                                                  &amp;&amp; len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>329: </span><span class='hs-definition'>map</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{v : [a] | notEmpty xs &lt;=&gt; notEmpty v}</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>a -&gt; b</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
</pre>\end{code}

\hint On what variables are the errors? How are those variables' values computed?
Can you think of a better specification for the function(s) doing those computations?

<div class="hwex" id="Mitchell's Risers">
Non-empty lists pop up in many places, and it is rather convenient
to have the type system track non-emptiness without having to make
up special types. Consider the `risers` function, popularized
by [Neil Mitchell][mitchell-riser]. `safeSplit` requires
its input be non-empty; but LiquidHaskell believes that the
call inside `risers` fails this requirement. Fix the
specification for `risers` so that it is verified.
</div>

\begin{code}
<pre><span class=hs-linenum>346: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>risers</span>       <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| notEmpty xs ==&gt; notEmpty v}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>347: </span><span class='hs-definition'>risers</span>           <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>348: </span><a class=annot href="#"><span class=annottext>forall a .
(Ord&lt;[]&gt; a) =&gt;
x2:[a] -&gt; {v : [[a]] | notEmpty x2 =&gt; notEmpty v}</span><span class='hs-definition'>risers</span></a> <span class='hs-conid'>[]</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | not (notEmpty v)
                                                  &amp;&amp; len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>349: </span><span class='hs-definition'>risers</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [[a]] | not (notEmpty v)
             &amp;&amp; len v == 0}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v
           &amp;&amp; head v == x}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>350: </span><span class='hs-definition'>risers</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-varid'>etc</span><span class='hs-layout'>)</span>
<span class=hs-linenum>351: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v
           &amp;&amp; head v == x
           &amp;&amp; len v == 1 + len s
           &amp;&amp; tail v == s}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{v : [a] | v == s
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>s</span></a><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{v : [[a]] | v == ss
             &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>ss</span></a>
<span class=hs-linenum>352: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v
           &amp;&amp; head v == x}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-keyglyph'>]</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{v : [[a]] | notEmpty v
             &amp;&amp; head v == s
             &amp;&amp; len v == 1 + len ss
             &amp;&amp; tail v == ss}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : [a] | v == s
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>s</span></a> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{v : [[a]] | v == ss
             &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>ss</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>353: </span>    <span class='hs-keyword'>where</span>
<span class=hs-linenum>354: </span>      <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : [a] | len VV &gt;= 0}</span><span class='hs-varid'>s</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : [[a]] | len VV &gt;= 0}</span><span class='hs-varid'>ss</span></a><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      {v : [a] | notEmpty v} -&gt; (a, [a]) | VV == safeSplit}</span><span class='hs-varid'>safeSplit</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>[[a]]</span><span class='hs-varid'>risers</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | notEmpty v
           &amp;&amp; head v == y
           &amp;&amp; len v == 1 + len etc
           &amp;&amp; tail v == etc}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{v : [a] | v == etc
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>etc</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>355: </span>
<span class=hs-linenum>356: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>safeSplit</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NEList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>357: </span><a class=annot href="#"><span class=annottext>forall a . {VV : [a] | notEmpty VV} -&gt; (a, [a])</span><span class='hs-definition'>safeSplit</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a b &lt;p2 :: a b -&gt; Bool&gt;.
      x1:a -&gt; x2:{VV : b&lt;p2 x1&gt; | true} -&gt; {v : (a, b)&lt;\x5 VV -&gt; {VV : b&lt;p2 x5&gt; | true}&gt; | fst v == x1
                                                                                           &amp;&amp; snd v == x2
                                                                                           &amp;&amp; x_Tuple21 v == x1
                                                                                           &amp;&amp; x_Tuple22 v == x2} | VV == (,)}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>358: </span><span class='hs-definition'>safeSplit</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a . {v : [GHC.Types.Char] | false} -&gt; a | VV == die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"don't worry, be happy"</span></a>
</pre>\end{code}



Recap
-----

In this chapter we saw how LiquidHaskell lets you

1. *Define* structural properties of data types,

2. *Use refinements* over these properties to describe key
   invariants that establish, at compile-time, the safety
   of operations that might otherwise fail on unexpected
   values at run-time, all while,

3. *Working with plain Haskell types*, here, Lists,
   without having to [make up new types][apple-riser]
   which can have the unfortunate effect of adding
   a multitude of constructors and conversions which
   often clutter implementations and specifications.

\noindent
Of course, we can do a lot more with measures, so lets press on!




</body>
</html>