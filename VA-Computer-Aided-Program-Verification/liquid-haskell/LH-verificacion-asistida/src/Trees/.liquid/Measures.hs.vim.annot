1:1-1:1::Trees.Measures.$trModule :: "GHC.Types.Module"
9:1-9:5::Trees.Measures.main :: "(GHC.Types.IO ())"
9:17-9:24::lq_anf$##7205759403792808647 :: "[GHC.Types.Char]"
18:1-18:4::Trees.Measures.die :: "forall a . {v : [GHC.Types.Char] | false} -> a"
18:5-18:8::msg :: "{VV : [GHC.Types.Char] | false}"
18:17-18:20::msg :: "{v : [GHC.Types.Char] | false}"
25:1-25:7::Trees.Measures.divide :: "GHC.Types.Int -> {VV : GHC.Types.Int | 0 /= VV} -> GHC.Types.Int"
25:14-25:34::Trees.Measures.die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
25:18-25:34::lq_anf$##7205759403792808747 :: "[GHC.Types.Char]"
26:14-26:15::ds_d3PW :: "GHC.Types.Int"
26:22-26:23::ds_d3PX :: "{v : GHC.Types.Int | 0 /= v}"
28:1-28:5::Trees.Measures.avg2 :: "GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int"
28:6-28:7::x :: "GHC.Types.Int"
28:8-28:9::y :: "GHC.Types.Int"
28:21-28:28::lq_anf$##7205759403792808748 :: "{v : GHC.Types.Int | v == x + y}"
28:22-28:23::x :: "{v : GHC.Types.Int | v == x}"
28:26-28:27::y :: "{v : GHC.Types.Int | v == y}"
28:33-28:34::lq_anf$##7205759403792808750 :: "GHC.Types.Int"
30:1-30:5::Trees.Measures.avg3 :: "GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int"
30:6-30:7::x :: "GHC.Types.Int"
30:8-30:9::y :: "GHC.Types.Int"
30:10-30:11::z :: "GHC.Types.Int"
30:21-30:32::lq_anf$##7205759403792808752 :: "GHC.Types.Int"
30:22-30:23::x :: "{v : GHC.Types.Int | v == x}"
30:26-30:27::y :: "{v : GHC.Types.Int | v == y}"
30:30-30:31::z :: "{v : GHC.Types.Int | v == z}"
30:33-30:34::lq_anf$##7205759403792808754 :: "GHC.Types.Int"
33:1-33:5::Trees.Measures.size :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | (notEmpty x1 => VV > 0)\n                                && VV >= 0}"
33:16-33:17::lq_anf$##7205759403792808771 :: "{v : GHC.Prim.Int# | v == 0}"
34:16-34:17::lq_anf$##7205759403792808773 :: "GHC.Types.Int"
34:20-34:27::lq_anf$##7205759403792808774 :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v >= 0}"
34:25-34:27::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
36:1-36:8::Trees.Measures.avgMany :: "[GHC.Types.Int] -> GHC.Types.Int"
36:9-36:11::xs :: "[GHC.Types.Int]"
36:14-36:32::Trees.Measures.divide :: "GHC.Types.Int -> {v : GHC.Types.Int | 0 /= v} -> GHC.Types.Int"
36:21-36:26::total :: "{v : GHC.Types.Int | v == total}"
36:27-36:32::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v == elems\n                     && v >= 0}"
38:5-38:10::total :: "GHC.Types.Int"
38:14-38:21::_ :: "GHC.Types.Int"
38:19-38:21::xs :: "{v : [GHC.Types.Int] | v == xs\n                       && len v >= 0}"
39:5-39:10::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v >= 0}"
39:14-39:21::Trees.Measures.size :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | (notEmpty x1 => VV > 0)\n                                && VV >= 0}"
39:19-39:21::xs :: "{v : [GHC.Types.Int] | v == xs\n                       && len v >= 0}"
42:1-42:9::Trees.Measures.notEmpty :: "forall a . x1:[a] -> {VV : GHC.Types.Bool | VV <=> notEmpty x1}"
42:18-42:23::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
43:18-43:22::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
52:1-52:8::Trees.Measures.average :: "{VV : [GHC.Types.Int] | notEmpty VV} -> GHC.Types.Int"
52:9-52:11::xs :: "{VV : [GHC.Types.Int] | notEmpty VV}"
52:14-52:32::Trees.Measures.divide :: "GHC.Types.Int -> {v : GHC.Types.Int | 0 /= v} -> GHC.Types.Int"
52:21-52:26::total :: "{v : GHC.Types.Int | v == total}"
52:27-52:32::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v == elems\n                     && v >= 0}"
54:5-54:10::total :: "GHC.Types.Int"
54:14-54:20::_ :: "GHC.Types.Int"
54:18-54:20::xs :: "{v : [GHC.Types.Int] | notEmpty v\n                       && v == xs\n                       && len v >= 0}"
55:5-55:10::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v >= 0}"
55:14-55:21::Trees.Measures.size :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | (notEmpty x1 => VV > 0)\n                                && VV >= 0}"
55:19-55:21::xs :: "{v : [GHC.Types.Int] | notEmpty v\n                       && v == xs\n                       && len v >= 0}"
58:1-58:9::Trees.Measures.average' :: "[GHC.Types.Int] -> (GHC.Maybe.Maybe GHC.Types.Int)"
58:10-58:12::xs :: "[GHC.Types.Int]"
59:17-59:21::_ :: "{VV : forall a .\n      x1:a -> {v : (GHC.Maybe.Maybe a) | isJust v\n                                         && fromJust v == x1} | VV == Just}"
59:24-59:45::lq_anf$##7205759403792808778 :: "GHC.Types.Int"
59:31-59:39::lq_anf$##7205759403792808777 :: "GHC.Types.Int"
59:36-59:38::xs :: "{v : [GHC.Types.Int] | v == xs\n                       && len v >= 0}"
59:40-59:45::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v == elems\n                     && v >= 0}"
60:17-60:24::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}"
62:5-62:10::elems :: "{v : GHC.Types.Int | (notEmpty xs => v > 0)\n                     && v >= 0}"
62:17-62:24::Trees.Measures.size :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | (notEmpty x1 => VV > 0)\n                                && VV >= 0}"
62:22-62:24::xs :: "{v : [GHC.Types.Int] | v == xs\n                       && len v >= 0}"
63:17-63:21::_ :: "{v : GHC.Types.Bool | v\n                      && v == True}"
66:1-66:6::Trees.Measures.size1 :: "forall a .\n{VV : [a] | notEmpty VV} -> {VV : GHC.Types.Int | 0 < VV}"
66:17-66:18::lq_anf$##7205759403792808766 :: "{v : GHC.Prim.Int# | v == 0}"
67:17-67:18::lq_anf$##7205759403792808768 :: "GHC.Types.Int"
67:21-67:29::lq_anf$##7205759403792808769 :: "{v : GHC.Types.Int | 0 < v}"
67:27-67:29::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
70:1-70:6::Trees.Measures.size2 :: "forall a . x1:[a] -> {v : GHC.Types.Int | notEmpty x1 => v > 0}"
70:17-70:18::lq_anf$##7205759403792808761 :: "{v : GHC.Prim.Int# | v == 0}"
71:17-71:18::lq_anf$##7205759403792808763 :: "GHC.Types.Int"
71:21-71:29::lq_anf$##7205759403792808764 :: "{v : GHC.Types.Int | notEmpty xs => v > 0}"
71:27-71:29::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
74:1-74:5::Trees.Measures.head :: "forall a . {VV : [a] | notEmpty VV} -> a"
74:15-74:16::x :: "{VV : a | VV == x}"
75:15-75:56::Trees.Measures.die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
75:19-75:56::lq_anf$##7205759403792808680 :: "[GHC.Types.Char]"
78:1-78:5::Trees.Measures.tail :: "forall a . {VV : [a] | notEmpty VV} -> [a]"
78:15-78:17::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
79:15-79:54::Trees.Measures.die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
79:19-79:54::lq_anf$##7205759403792808683 :: "[GHC.Types.Char]"
82:1-82:9::Trees.Measures.safeHead :: "forall a . [a] -> (GHC.Maybe.Maybe a)"
82:10-82:12::xs :: "[a]"
83:5-83:12::lq_anf$##7205759403792808703 :: "GHC.Types.Bool"
83:10-83:12::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
83:17-83:24::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}"
84:17-84:21::_ :: "{VV : forall a .\n      x1:a -> {v : (GHC.Maybe.Maybe a) | isJust v\n                                         && fromJust v == x1} | VV == Just}"
84:24-84:31::lq_anf$##7205759403792808706 :: "a"
84:29-84:31::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
88:1-88:5::Trees.Measures.null :: "forall a . [a] -> GHC.Types.Bool"
88:18-88:22::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
89:18-89:23::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
93:1-93:8::Trees.Measures.groupEq :: "forall a . (Eq<[]> a) => [a] -> [{VV : [a] | notEmpty VV}]"
93:18-93:20::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | not (notEmpty v)\n                                                  && len v == 0} | VV == []}"
94:18-94:24::lq_anf$##7205759403792808709 :: "{v : [a] | notEmpty v\n           && head v == x\n           && len v == 1 + len ys\n           && tail v == ys}"
94:19-94:20::x :: "{VV : a | VV == x}"
94:21-94:23::ys :: "{v : [a] | v == ys\n           && len v >= 0\n           && len v <= len xs}"
94:27-94:37::lq_anf$##7205759403792808710 :: "[{v : [a] | notEmpty v}]"
94:35-94:37::zs :: "{v : [a] | v == zs\n           && len v >= 0\n           && len v <= len xs}"
96:6-96:8::ys :: "{VV : [a] | len VV >= 0\n            && len VV <= len xs}"
96:10-96:12::zs :: "{VV : [a] | len VV >= 0\n            && len VV <= len xs}"
96:18-96:32::lq_anf$##7205759403792808708 :: "x1:a -> {v : GHC.Types.Bool | v <=> x == x1}"
96:23-96:29::_ :: "GHC.Types.Bool"
96:24-96:25::x :: "{VV : a | VV == x}"
96:30-96:32::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
100:1-100:17::Trees.Measures.eliminateStutter :: "forall a . (Eq<[]> a) => [a] -> [a]"
100:18-100:20::xs :: "[a]"
100:23-100:31::lq_anf$##7205759403792808738 :: "x1:[[a]] -> {v : [a] | notEmpty x1 <=> notEmpty v}"
100:27-100:31::_ :: "{VV : forall a . {v : [a] | notEmpty v} -> a | VV == head}"
100:34-100:44::lq_anf$##7205759403792808739 :: "[{v : [a] | notEmpty v}]"
100:42-100:44::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
103:1-103:7::Trees.Measures.foldl1 :: "forall a . (a -> a -> a) -> {VV : [a] | notEmpty VV} -> a"
103:8-103:9::f :: "a -> a -> a"
103:22-103:34::Trees.Measures.foldl :: "forall a b . (a -> b -> a) -> a -> [b] -> a"
103:28-103:29::f :: "a -> a -> a"
103:30-103:31::x :: "{VV : a | VV == x}"
103:32-103:34::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
104:22-104:34::Trees.Measures.die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
104:26-104:34::lq_anf$##7205759403792808715 :: "[GHC.Types.Char]"
107:1-107:6::Trees.Measures.foldl :: "forall a b . (a -> b -> a) -> a -> [b] -> a"
107:9-107:12::acc :: "a"
107:22-107:25::acc :: "{VV : a | VV == acc}"
108:22-108:42::Trees.Measures.foldl :: "forall a b . (a -> b -> a) -> a -> [b] -> a"
108:28-108:29::ds_d3O0 :: "a -> b -> a"
108:30-108:39::lq_anf$##7205759403792808712 :: "a"
108:33-108:36::acc :: "{VV : a | VV == acc}"
108:37-108:38::x :: "{VV : a | VV == x}"
108:40-108:42::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
111:1-111:4::Trees.Measures.sum :: "forall a . (Num<[]> a) => {VV : [a] | notEmpty VV} -> a"
111:11-111:41::Trees.Measures.die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
111:15-111:41::lq_anf$##7205759403792808719 :: "[GHC.Types.Char]"
112:11-112:24::Trees.Measures.foldl1 :: "{VV : forall a .\n      (a -> a -> a) -> {v : [a] | notEmpty v} -> a | VV == foldl1}"
112:18-112:21::lq_anf$##7205759403792808717 :: "x1:a -> x2:a -> {VV : a | VV == x1 + x2}"
112:22-112:24::ds_d3Rc :: "{v : [a] | notEmpty v\n           && len v >= 0}"
114:1-114:6::Trees.Measures.sumOk :: "GHC.Integer.Type.Integer"
114:14-114:25::lq_anf$##7205759403792808732 :: "{v : [GHC.Integer.Type.Integer] | notEmpty v}"
114:15-114:16::lq_anf$##7205759403792808722 :: "{v : GHC.Integer.Type.Integer | v == 1}"
114:17-114:18::lq_anf$##7205759403792808723 :: "{v : GHC.Integer.Type.Integer | v == 2}"
114:19-114:20::lq_anf$##7205759403792808724 :: "{v : GHC.Integer.Type.Integer | v == 3}"
114:21-114:22::lq_anf$##7205759403792808725 :: "{v : GHC.Integer.Type.Integer | v == 4}"
114:23-114:24::lq_anf$##7205759403792808726 :: "{v : GHC.Integer.Type.Integer | v == 5}"
116:1-116:7::Trees.Measures.sumBad :: "GHC.Integer.Type.Integer"
116:14-116:16::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | not (notEmpty v)\n                                                  && len v == 0} | VV == []}"
119:1-119:10::Trees.Measures.wtAverage :: "{VV : [({VV : GHC.Types.Int | 0 < VV}, {VV : GHC.Types.Int | 0 < VV})] | notEmpty VV} -> GHC.Types.Int"
119:11-119:14::wxs :: "{VV : [({VV : GHC.Types.Int | 0 < VV}, {VV : GHC.Types.Int | 0 < VV})] | notEmpty VV}"
119:17-119:42::Trees.Measures.divide :: "GHC.Types.Int -> {v : GHC.Types.Int | 0 /= v} -> GHC.Types.Int"
119:24-119:32::totElems :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && v == totElems\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
119:33-119:42::totWeight :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && v == totWeight\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
121:5-121:10::elems :: "{v : [GHC.Types.Int] | notEmpty wxs <=> notEmpty v}"
121:17-121:43::lq_anf$##7205759403792808759 :: "(GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Int"
121:21-121:39::lq_anf$##7205759403792808758 :: "(GHC.Types.Int, GHC.Types.Int)"
121:33-121:34::w :: "{v : GHC.Types.Int | v == w}"
121:37-121:38::x :: "{v : GHC.Types.Int | v == x}"
121:40-121:43::wxs :: "{v : [({v : GHC.Types.Int | 0 < v}, {v : GHC.Types.Int | 0 < v})] | notEmpty v\n                                                                    && v == wxs\n                                                                    && len v >= 0}"
122:5-122:12::weights :: "{v : [GHC.Types.Int] | notEmpty wxs <=> notEmpty v}"
122:17-122:43::lq_anf$##7205759403792808757 :: "({VV : GHC.Types.Int | (notEmpty wxs => VV > 0)\n                       && 0 /= VV\n                       && VV /= 0\n                       && VV > 0\n                       && VV >= 0\n                       && 0 < VV}, GHC.Types.Int) -> GHC.Types.Int"
122:21-122:39::lq_anf$##7205759403792808756 :: "({v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                      && 0 /= v\n                      && v /= 0\n                      && v > 0\n                      && v >= 0\n                      && 0 < v}, GHC.Types.Int)"
122:33-122:34::w :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && v == w\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
122:40-122:43::wxs :: "{v : [({v : GHC.Types.Int | 0 < v}, {v : GHC.Types.Int | 0 < v})] | notEmpty v\n                                                                    && v == wxs\n                                                                    && len v >= 0}"
123:5-123:13::totElems :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
123:17-123:26::_ :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
123:21-123:26::elems :: "{v : [GHC.Types.Int] | (notEmpty wxs <=> notEmpty v)\n                       && v == elems\n                       && len v >= 0}"
124:5-124:14::totWeight :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
124:17-124:28::_ :: "{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                     && 0 /= v\n                     && v /= 0\n                     && v > 0\n                     && v >= 0\n                     && 0 < v}"
124:21-124:28::weights :: "{v : [GHC.Types.Int] | (notEmpty wxs <=> notEmpty v)\n                       && v == weights\n                       && len v >= 0}"
125:5-125:8::sum :: "{v : [{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                           && 0 /= v\n                           && v /= 0\n                           && v > 0\n                           && v >= 0\n                           && 0 < v}] | notEmpty v} -> {v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                                                                            && 0 /= v\n                                                                            && v /= 0\n                                                                            && v > 0\n                                                                            && v >= 0\n                                                                            && 0 < v}"
125:17-125:27::_ :: "{v : [{v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                           && 0 /= v\n                           && v /= 0\n                           && v > 0\n                           && v >= 0\n                           && 0 < v}] | notEmpty v} -> {v : GHC.Types.Int | (notEmpty wxs => v > 0)\n                                                                            && 0 /= v\n                                                                            && v /= 0\n                                                                            && v > 0\n                                                                            && v >= 0\n                                                                            && 0 < v}"
125:24-125:27::lq_anf$##7205759403792808755 :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 + x2}"
129:1-129:4::Trees.Measures.map :: "forall a b .\n(a -> b) -> x3:[a] -> {ys : [b] | notEmpty x3 <=> notEmpty ys}"
129:18-129:20::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | not (notEmpty v)\n                                                  && len v == 0} | VV == []}"
130:18-130:21::lq_anf$##7205759403792808735 :: "a"
130:20-130:21::x :: "{VV : a | VV == x}"
130:24-130:32::lq_anf$##7205759403792808736 :: "{v : [a] | notEmpty xs <=> notEmpty v}"
130:28-130:29::ds_d3NO :: "a -> b"
130:30-130:32::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
134:1-134:7::Trees.Measures.risers :: "forall a . (Ord<[]> a) => [a] -> [[a]]"
134:20-134:22::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | not (notEmpty v)\n                                                  && len v == 0} | VV == []}"
135:20-135:25::lq_anf$##7205759403792808691 :: "{v : [[a]] | not (notEmpty v)\n             && len v == 0}"
135:21-135:24::lq_anf$##7205759403792808690 :: "{v : [a] | notEmpty v\n           && head v == x}"
135:22-135:23::x :: "{VV : a | VV == x}"
137:5-137:6::x :: "{VV : a | VV == x}"
137:10-137:11::y :: "{VV : a | VV == y}"
137:20-137:25::lq_anf$##7205759403792808700 :: "{v : [a] | notEmpty v\n           && head v == x\n           && len v == 1 + len s\n           && tail v == s}"
137:21-137:22::x :: "{VV : a | VV == x}"
137:23-137:24::s :: "{v : [a] | v == s\n           && len v >= 0}"
137:28-137:30::ss :: "{v : [[a]] | v == ss\n             && len v >= 0}"
138:20-138:23::lq_anf$##7205759403792808698 :: "{v : [a] | notEmpty v\n           && head v == x}"
138:21-138:22::x :: "{VV : a | VV == x}"
138:26-138:34::lq_anf$##7205759403792808699 :: "{v : [[a]] | notEmpty v\n             && head v == s\n             && len v == 1 + len ss\n             && tail v == ss}"
138:27-138:28::s :: "{v : [a] | v == s\n           && len v >= 0}"
138:31-138:33::ss :: "{v : [[a]] | v == ss\n             && len v >= 0}"
140:8-140:9::s :: "[a]"
140:11-140:13::ss :: "[[a]]"
140:20-140:29::_ :: "{VV : forall a .\n      {v : [a] | notEmpty v} -> (a, [a]) | VV == safeSplit}"
140:32-140:46::lq_anf$##7205759403792808694 :: "[[a]]"
140:39-140:46::lq_anf$##7205759403792808693 :: "{v : [a] | notEmpty v\n           && head v == y\n           && len v == 1 + len etc\n           && tail v == etc}"
140:40-140:41::y :: "{VV : a | VV == y}"
140:42-140:45::etc :: "{v : [a] | v == etc\n           && len v >= 0}"
143:1-143:10::Trees.Measures.safeSplit :: "forall a . {VV : [a] | notEmpty VV} -> (a, [a])"
143:20-143:27::GHC.Tuple.(,) :: "{VV : forall a b <p2 :: a b -> Bool>.\n      x1:a -> x2:{VV : b<p2 x1> | true} -> {v : (a, b)<\\x5 VV -> {VV : b<p2 x5> | true}> | fst v == x1\n                                                                                           && snd v == x2\n                                                                                           && x_Tuple21 v == x1\n                                                                                           && x_Tuple22 v == x2} | VV == (,)}"
143:21-143:22::x :: "{VV : a | VV == x}"
143:24-143:26::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
144:20-144:47::Trees.Measures.die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
144:24-144:47::lq_anf$##7205759403792808686 :: "[GHC.Types.Char]"