1:1-1:1::Trees.Trees.$trModule :: "GHC.Types.Module"
24:1-24:4::Trees.Trees.die :: "forall a . {VV : [GHC.Types.Char] | false} -> a"
24:5-24:8::msg :: "{VV : [GHC.Types.Char] | false}"
24:17-24:20::msg :: "{v : [GHC.Types.Char] | false}"
71:1-71:9::Trees.Trees.nonEmpty :: "forall a .\nx1:(Trees.Trees.BST a) -> {VV : GHC.Types.Bool | VV <=> nonEmpty x1}"
71:27-71:32::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
72:27-72:31::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
75:1-75:7::Trees.Trees.delMin :: "forall a .\n{t : (Trees.Trees.BST a) | nonEmpty t} -> (Trees.Trees.MinPair a)"
75:26-75:32::Trees.Trees.MP :: "{VV : forall a .\n      x1:a -> x2:(Trees.Trees.BST {VV : a | x1 < VV}) -> {v : (Trees.Trees.MinPair a) | mElt v == x1\n                                                                                        && rest v == x2} | VV == MP}"
75:29-75:30::k :: "{VV : a | VV == k}"
75:31-75:32::r :: "{v : (Trees.Trees.BST {VV : a | k < VV}) | v == r}"
76:26-76:45::Trees.Trees.MP :: "{VV : forall a .\n      x1:a -> x2:(Trees.Trees.BST {VV : a | x1 < VV}) -> {v : (Trees.Trees.MinPair a) | mElt v == x1\n                                                                                        && rest v == x2} | VV == MP}"
76:29-76:31::k' :: "{VV : a | VV == k'\n          && VV /= k\n          && VV < k\n          && VV <= k}"
76:32-76:45::lq_anf$##7205759403792811252 :: "{v : (Trees.Trees.BST a) | nonEmpty v\n                           && left v == l'\n                           && right v == r\n                           && root v == k}"
76:38-76:39::k :: "{VV : a | VV == k}"
76:40-76:42::l' :: "{v : (Trees.Trees.BST {VV : a | VV /= k\n                                && VV /= k'\n                                && VV > k'\n                                && VV >= k'\n                                && VV < k\n                                && k' < VV\n                                && VV <= k\n                                && k' <= VV}) | v == l'}"
76:43-76:44::r :: "{v : (Trees.Trees.BST {VV : a | k < VV}) | v == r}"
78:8-78:10::k' :: "{VV : a | VV /= k\n          && VV < k\n          && VV <= k}"
78:11-78:13::l' :: "(Trees.Trees.BST {VV : a | VV /= k\n                           && VV /= k'\n                           && VV > k'\n                           && VV >= k'\n                           && VV < k\n                           && k' < VV\n                           && VV <= k\n                           && k' <= VV})"
78:26-78:34::Trees.Trees.delMin :: "forall a .\n{t : (Trees.Trees.BST a) | nonEmpty t} -> (Trees.Trees.MinPair a)"
78:33-78:34::ds_d4zn :: "(Trees.Trees.BST {VV : a | VV < k})"
79:26-79:59::Trees.Trees.die :: "{VV : forall a . {v : [GHC.Types.Char] | false} -> a | VV == die}"
79:30-79:59::lq_anf$##7205759403792811250 :: "[GHC.Types.Char]"
88:1-88:5::Trees.Trees.join :: "forall a .\nx1:a -> (Trees.Trees.IncList {VV : a | VV <= x1}) -> (Trees.Trees.IncList {VV : a | VV >= x1}) -> (Trees.Trees.IncList a)"
88:6-88:7::z :: "a"
88:18-88:20::ys :: "(Trees.Trees.IncList {VV : a | VV >= z})"
88:23-88:24::z :: "{VV : a | VV == z}"
88:28-88:30::ys :: "{v : (Trees.Trees.IncList {VV : a | VV >= z}) | v == ys}"
89:23-89:24::x :: "{VV : a | VV == x\n          && VV <= z}"
89:28-89:40::lq_anf$##7205759403792811258 :: "(Trees.Trees.IncList a)"
89:33-89:34::z :: "{VV : a | VV == z}"
89:35-89:37::xs :: "{v : (Trees.Trees.IncList {VV : a | VV <= z\n                                    && x <= VV}) | v == xs}"
89:38-89:40::ys :: "{v : (Trees.Trees.IncList {VV : a | VV >= z}) | v == ys}"
115:1-115:11::Trees.Trees.refineSkew :: "forall a .\n(Ord<[]> a) =>\nx2:(Trees.Trees.SkewH a) -> (Trees.Trees.SkewH {VV : a | sk x2 <= VV})"
115:27-115:39::Trees.Trees.Skew :: "{VV : forall a .\n      x1:a -> x2:(Trees.Trees.SkewH {VV : a | x1 <= VV}) -> x3:(Trees.Trees.SkewH {VV : a | x1 <= VV}) -> {v : (Trees.Trees.SkewH a) | sLeft v == x2\n                                                                                                                                       && sRight v == x3\n                                                                                                                                       && sk v == x1} | VV == Skew}"
115:33-115:34::a :: "{VV : a | VV == a}"
115:35-115:36::b :: "{v : (Trees.Trees.SkewH {VV : a | a <= VV}) | v == b}"
115:37-115:38::c :: "{v : (Trees.Trees.SkewH {VV : a | a <= VV}) | v == c}"
116:20-116:25::_ :: "{VV : forall a . (Trees.Trees.SkewH a) | VV == Empty}"
120:1-120:7::Trees.Trees.joinSk :: "forall a .\n(Ord<[]> a) =>\n(Trees.Trees.SkewH a) -> (Trees.Trees.SkewH a) -> (Trees.Trees.SkewH a)"
120:22-120:27::_ :: "{VV : forall a . (Trees.Trees.SkewH a) | VV == Empty}"
121:19-121:21::ds_d4xe :: "(Trees.Trees.SkewH a)"
122:26-122:28::ds_d4xd :: "(Trees.Trees.SkewH a)"
124:5-124:7::ds_d4ym :: "a"
124:11-124:13::k2 :: "{VV : a | VV == k2}"
124:16-124:56::Trees.Trees.Skew :: "{VV : forall a .\n      x1:a -> x2:(Trees.Trees.SkewH {VV : a | x1 <= VV}) -> x3:(Trees.Trees.SkewH {VV : a | x1 <= VV}) -> {v : (Trees.Trees.SkewH a) | sLeft v == x2\n                                                                                                                                       && sRight v == x3\n                                                                                                                                       && sk v == x1} | VV == Skew}"
124:21-124:23::ds_d4ym :: "a"
124:24-124:52::lq_anf$##7205759403792811269 :: "(Trees.Trees.SkewH a)"
124:32-124:35::ds_d4yo :: "(Trees.Trees.SkewH a)"
124:36-124:51::lq_anf$##7205759403792811268 :: "(Trees.Trees.SkewH a)"
124:48-124:50::ds_d4xe :: "(Trees.Trees.SkewH a)"
124:53-124:56::ds_d4yn :: "(Trees.Trees.SkewH a)"
125:17-125:29::Trees.Trees.joinSk :: "forall a .\n(Ord<[]> a) =>\n(Trees.Trees.SkewH a) -> (Trees.Trees.SkewH a) -> (Trees.Trees.SkewH a)"
125:24-125:26::ds_d4xe :: "(Trees.Trees.SkewH a)"
125:27-125:29::ds_d4xd :: "(Trees.Trees.SkewH a)"