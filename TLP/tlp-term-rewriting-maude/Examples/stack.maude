***Author: Adrian Riesco

fmod STACK is
 *** Predefined natural numbers are imported
 pr NAT .

 sort Stack .

 *** We define mt (empty) and push as constructors:
 op mt : -> Stack [ctor] .
 op push : Nat Stack -> Stack [ctor] .

 var N : Nat .
 var P : Stack .

 *** The pop function is total, it does not modify the stack when empty:
 op pop : Stack -> Stack .
 eq pop(mt) = mt .
 eq pop(push(N, P)) = P .

 *** The function top is partial, so we use ~>. Equations for erros are not required.
 op top : Stack ~> Nat .
 eq top(push(N, P)) = N .
endfm

*** The singleton stack containing 7
red push(7, mt) .

*** The stack containing 7 at the bottom and 3 on top is specified as push(3, push(7, mt))
red push(3, push(7, mt)) .

*** If we apply pop to the previous stack we obtain the first one
red pop(push(3, push(7, mt))) .

*** The top of the stack after applying pop is 7
red top(pop(push(3, push(7, mt)))) .

fmod EXT-STACK is
 pr STACK .

 vars N N' : Nat .
 var  P : Stack .

 op is? : Stack Nat -> Bool .
 eq is?(mt, N) = false .
 eq is?(push(N, P), N') = if N == N'
                          then true
                          else is?(P, N')
                          fi .

 ***( Different implementations:
   - Using conditional equations:
   eq is?(mt, N) = false .
   eq is?(push(N, P), N) = true .
   ceq is?(push(N, P), N') = is?(P, N')
    if N =/= N' .
   - Using the otherwise attribute:
   eq is?(mt, N) = false .
   eq is?(push(N, P), N) = true .
   eq is?(push(N, P), N') = is?(P, N') [owise] .
 )

 op isEmpty? : Stack -> Bool .
 eq isEmpty?(mt) = true .
 eq isEmpty?(P) = true [owise] .
endfm